<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>clip</title>
      <link href="/2024/06/06/clip/"/>
      <url>/2024/06/06/clip/</url>
      
        <content type="html"><![CDATA[<ul><li>前言：在最近所接触学习的开放词汇视觉感知模型中，有许多模型是基于clip迁移改进的，CLIP 证明了利用自然语言监督学习图像表示是可行的，打破了以往依赖大量人工标注数据的传统模式，为计算机视觉的发展开辟了新的方向。</li><li>由于自然语言数据规模庞大且获取成本低廉，这使得 CLIP 能够学习到更丰富、更抽象的视觉概念和语义信息。</li><li>为了更好地掌握一些分类，检测等任务的思想，有必要研读这一经典模型</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip-all.png"></p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>近年来，直接从原始文本中学习的预训练方法彻底改变了自然语言处理 (NLP)，然而，在其他领域，例如计算机视觉中，仍然标准地使用在 ImageNet 等众包标注数据集上预训练模型。可扩展的预训练方法，它们直接从 Web 文本中学习，很难在计算机视觉领域产生类似的突破</li><li>一个直观的想法：从网络文本中学习的预训练方法能否应用在计算机视觉方面。孕育而生</li><li>有不少针对该想法产生的模型，但并未达到非常理想的效果，作者认为问题在于训练数据集规模</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="采用自然语言监督"><a href="#采用自然语言监督" class="headerlink" title="采用自然语言监督"></a>采用自然语言监督</h2><ul><li>CLIP 的核心思想是学习感知，其监督信息来源于自然语言。</li></ul><h2 id="需要足够大的数据集"><a href="#需要足够大的数据集" class="headerlink" title="需要足够大的数据集"></a>需要足够大的数据集</h2><ul><li>已存在的数据集要么在规模，要么在质量上远达不到训练所需的要求，需要自己重新采集数据集</li></ul><h2 id="选择有效训练方法"><a href="#选择有效训练方法" class="headerlink" title="选择有效训练方法"></a>选择有效训练方法</h2><ul><li>对比学习，预测哪些文本整体与哪些图像配对，而不是该文本的确切词语</li></ul><h2 id="选择和扩展模型"><a href="#选择和扩展模型" class="headerlink" title="选择和扩展模型"></a>选择和扩展模型</h2><ul><li>文本编码器：Transformer</li><li>图像编码器：resnet|ViT</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip-code.png"></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><ul><li>对于 ResNet，作者训练了 ResNet-50、ResNet-101，然后是 3 个遵循 EfﬁcientNet 风格模型缩放的模型，它们的计算量分别约为 ResNet-50 的 4 倍、16 倍和 64 倍。它们分别表示为 RN50x4、RN50x16 和 RN50x64。</li><li>对于 Vision Transformer，作者训练了 ViT-B&#x2F;32、ViT-B&#x2F;16 和 ViT-L&#x2F;14。所有模型都训练了 32 个 epoch。</li><li>ViT-L&#x2F;14@336px效果最佳</li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="零样本迁移"><a href="#零样本迁移" class="headerlink" title="零样本迁移"></a>零样本迁移</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>作者认为，传统的计算机视觉模型通常需要大量的标注数据进行训练，限制了其泛化能力。而 CLIP 通过从自然语言中学习视觉概念，可以实现更广泛的泛化，并减少对标注数据的依赖。</li></ul><h3 id="使用clip进行零样本迁移"><a href="#使用clip进行零样本迁移" class="headerlink" title="使用clip进行零样本迁移"></a>使用clip进行零样本迁移</h3><ul><li>CLIP 预训练用于预测图像和文本片段的配对关系，这使其能够将图像与数据集中所有类的名称进行匹配，从而实现零样本分类。</li></ul><h3 id="与-VISUAL-N-GRAMS-的初步比较"><a href="#与-VISUAL-N-GRAMS-的初步比较" class="headerlink" title="与 VISUAL N-GRAMS 的初步比较"></a>与 VISUAL N-GRAMS 的初步比较</h3><ul><li>CLIP 在 ImageNet 零样本分类任务上显著优于 Visual N-Grams，准确率从 11.5% 提高到 76.2%。</li></ul><h3 id="PROMPT-ENGINEERING-和-ENSEMBLING"><a href="#PROMPT-ENGINEERING-和-ENSEMBLING" class="headerlink" title="PROMPT ENGINEERING 和 ENSEMBLING"></a>PROMPT ENGINEERING 和 ENSEMBLING</h3><ul><li><p>PROMPT ENGINEERING</p><ul><li>使用提示模板例如“A photo of a {label}.” ，可以帮助指定文本是关于图像内容的。这通常比仅使用标签文本的基线方法提高了性能</li></ul></li><li><p>ENSEMBLING</p><ul><li>作者实验了在多个零样本分类器上进行集成作为提高性能的另一种方法。这些分类器是通过使用不同的上下文提示（例如“A photo of a big {label}” 和 “A photo of a small {label}”）来计算的。作者发现，在许多生成的零样本分类器之间进行集成可以可靠地提高性能。</li></ul></li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip-figure4.png"></p><h3 id="零样本-CLIP-性能分析"><a href="#零样本-CLIP-性能分析" class="headerlink" title="零样本 CLIP 性能分析"></a>零样本 CLIP 性能分析</h3><ul><li>CLIP 在大多数数据集上与完全监督的基线模型性能相当，并在一些数据集上表现更优。但 CLIP 在一些复杂和抽象的任务上表现较弱。</li></ul><h3 id="各个方面性能比较"><a href="#各个方面性能比较" class="headerlink" title="各个方面性能比较"></a>各个方面性能比较</h3><p>含大量性能比较的数据可参看论文，这里不做一一展示</p><h4 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h4><ul><li>论文通过线性探针实验评估了 CLIP 表示学习的效果，发现其在图像识别、OCR、动作识别、地理定位等多个任务上都取得了优异的性能。</li></ul><h4 id="对自然分布偏移的鲁棒性"><a href="#对自然分布偏移的鲁棒性" class="headerlink" title="对自然分布偏移的鲁棒性"></a>对自然分布偏移的鲁棒性</h4><ul><li>论文发现，与在 ImageNet 上预训练的模型相比，CLIP 模型在自然分布偏移方面具有更高的鲁棒性。</li></ul><h4 id="与人类性能的比较"><a href="#与人类性能的比较" class="headerlink" title="与人类性能的比较"></a>与人类性能的比较</h4><ul><li>论文通过在 Oxford IIT Pets 数据集上进行人类实验，发现 CLIP 在零样本学习方面具有潜力，但与人类学习方式仍存在差距。</li></ul><h4 id="数据重叠分析"><a href="#数据重叠分析" class="headerlink" title="数据重叠分析"></a>数据重叠分析</h4><ul><li>论文分析了数据集与预训练数据之间的重叠情况，发现重叠率较低，对模型性能的影响也较小。</li></ul><h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><ul><li>CLIP 在某些任务上的性能仍需改进，例如细粒度分类、抽象任务和未见过的任务。</li><li>CLIP 在小样本学习方面的效果不如人类。</li><li>CLIP 在分布外数据上的泛化能力仍有待提高。</li><li>CLIP 的零样本分类器无法生成新的输出。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习|计算机视觉|多模态大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的基于Linux的web服务器</title>
      <link href="/2024/06/06/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E4%BA%8ELinux%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/06/06/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E4%BA%8ELinux%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>该web服务器基于epoll红黑树模型构建，能够较好地应对多客户端请求</li><li>该demo旨在更好地理解http协议，包括发送报文，响应报文以及中间tcp协议的三次握手</li></ul><h2 id="设备与实验环境"><a href="#设备与实验环境" class="headerlink" title="设备与实验环境"></a>设备与实验环境</h2><ul><li>基于Linux内核的Ubuntu操作系统</li><li>开发工具vim</li><li>编程语言C</li><li>网络库Socket</li></ul><h2 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h2><ul><li>直接将头文件与源文件编译生成可执行文件运行即可</li></ul><h1 id="epoll-server-h"><a href="#epoll-server-h" class="headerlink" title="epoll_server.h"></a>epoll_server.h</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EPOLL_SERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EPOLL_SERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_listen_fd</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> epfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">epoll_run</span><span class="params">(<span class="type">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_accept</span><span class="params">(<span class="type">int</span> lfd, <span class="type">int</span> epfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* request, <span class="type">int</span> cfd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_respond_head</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> no, <span class="type">const</span> <span class="type">char</span>* desp, <span class="type">const</span> <span class="type">char</span>* type, <span class="type">long</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_file</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_dir</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* dirname)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="epoll-server-c"><a href="#epoll-server-c" class="headerlink" title="epoll_server.c"></a>epoll_server.c</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoll_server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 2000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_error</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> status, <span class="type">char</span> *title, <span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%d\r\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n&quot;</span>, status, title);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;body bgcolor=\&quot;#cc99cc\&quot;&gt;&lt;h2 align=\&quot;center\&quot;&gt;%d %s&lt;/h4&gt;\n&quot;</span>, status, title);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;%s\n&quot;</span>, text);</span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">epoll_run</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个epoll树的根节点</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>) &#123;   </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加要监听的节点</span></span><br><span class="line">    <span class="comment">// 先添加监听lfd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">init_listen_fd</span>(port, epfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托内核检测添加到树上的节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> all[MAXSIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, all, MAXSIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历发生变化的节点</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ret; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只处理读事件, 其他事件默认不处理</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *pev = &amp;all[i];</span><br><span class="line">            <span class="keyword">if</span>(!(pev-&gt;events &amp; EPOLLIN)) &#123;</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// 不是读事件</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pev-&gt;data.fd == lfd)&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="comment">// 接受连接请求</span></span><br><span class="line">                <span class="built_in">do_accept</span>(lfd, epfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 读数据</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;======================before do read, ret = %d\n&quot;</span>, ret);</span><br><span class="line">                <span class="built_in">do_read</span>(pev-&gt;data.fd, epfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;=========================================after do read\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将浏览器发过来的数据, 读到buf中 </span></span><br><span class="line">    <span class="type">char</span> line[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 读请求行</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">get_line</span>(cfd, line, <span class="built_in">sizeof</span>(line));</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭套接字, cfd从epoll上del</span></span><br><span class="line">        <span class="built_in">disconnect</span>(cfd, epfd);         </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;============= 请求头 ============\n&quot;</span>);   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求行数据: %s&quot;</span>, line);</span><br><span class="line">        <span class="comment">// 还有数据没读完,继续读走</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">len = <span class="built_in">get_line</span>(cfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;============= The End ============\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断get请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(<span class="string">&quot;get&quot;</span>, line, <span class="number">3</span>) == <span class="number">0</span>) &#123; <span class="comment">// 请求行: get /hello.c http/1.1   </span></span><br><span class="line">        <span class="comment">// 处理http请求</span></span><br><span class="line">        <span class="built_in">http_request</span>(line, cfd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭套接字, cfd从epoll上del</span></span><br><span class="line">        <span class="built_in">disconnect</span>(cfd, epfd);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断开连接的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, cfd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;   </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl del cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http请求处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* request, <span class="type">int</span> cfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 拆分http请求行</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">12</span>], path[<span class="number">1024</span>], protocol[<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(request, <span class="string">&quot;%[^ ] %[^ ] %[^ ]&quot;</span>, method, path, protocol);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method = %s, path = %s, protocol = %s\n&quot;</span>, method, path, protocol);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转码 将不能识别的中文乱码 -&gt; 中文</span></span><br><span class="line">    <span class="comment">// 解码 %23 %34 %5f</span></span><br><span class="line">    <span class="built_in">decode_str</span>(path, path);</span><br><span class="line">        </span><br><span class="line">    <span class="type">char</span>* file = path+<span class="number">1</span>; <span class="comment">// 去掉path中的/ 获取访问文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有指定访问的资源, 默认显示资源目录中的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>) &#123;    </span><br><span class="line">        <span class="comment">// file的值, 资源目录的当前位置</span></span><br><span class="line">        file = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件属性</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">stat</span>(file, &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;NO such file or direntry&quot;</span>);     </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是目录还是文件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;  <span class="comment">// 目录 </span></span><br><span class="line">        <span class="comment">// 发送头信息</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd, <span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(<span class="string">&quot;.html&quot;</span>), <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 发送目录信息</span></span><br><span class="line">        <span class="built_in">send_dir</span>(cfd, file);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode)) &#123; <span class="comment">// 文件        </span></span><br><span class="line">        <span class="comment">// 发送消息报头</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd, <span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(file), st.st_size);</span><br><span class="line">        <span class="comment">// 发送文件内容</span></span><br><span class="line">        <span class="built_in">send_file</span>(cfd, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送目录内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_dir</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* dirname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼一个html页面&lt;table&gt;&lt;/table&gt;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4094</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名: %s&lt;/title&gt;&lt;/head&gt;&quot;</span>, dirname);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;body&gt;&lt;h1&gt;当前目录: %s&lt;/h1&gt;&lt;table&gt;&quot;</span>, dirname);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> enstr[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目录项二级指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>** ptr;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">scandir</span>(dirname, &amp;ptr, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">char</span>* name = ptr[i]-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接文件的完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(path, <span class="string">&quot;%s/%s&quot;</span>, dirname, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;path = %s ===================\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">        <span class="built_in">stat</span>(path, &amp;st);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码生成 %E5 %A7 之类的东西</span></span><br><span class="line">        <span class="built_in">encode_str</span>(enstr, <span class="built_in">sizeof</span>(enstr), name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode)) &#123;       </span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;<span class="comment">// 如果是目录       </span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), </span><br><span class="line">                    <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>,</span><br><span class="line">                    enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 字符串拼接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dir message send OK!!!!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR* dir = <span class="built_in">opendir</span>(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读目录</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( (ptr = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* name = ptr-&gt;d_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送响应头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_respond_head</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> no, <span class="type">const</span> <span class="type">char</span>* desp, <span class="type">const</span> <span class="type">char</span>* type, <span class="type">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 状态行</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;http/1.1 %d %s\r\n&quot;</span>, no, desp);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 消息报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, type);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%ld\r\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 空行</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_file</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;   </span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;NO such file or direntry&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读文件</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( (len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span> ) &#123;   </span><br><span class="line">        <span class="comment">// 发送读出的数据</span></span><br><span class="line">        ret = <span class="built_in">send</span>(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error:&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>)  &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read file error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析http请求消息的每一行内容</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((i &lt; size - <span class="number">1</span>) &amp;&amp; (c != <span class="string">&#x27;\n&#x27;</span>)) &#123;    </span><br><span class="line">        n = <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;        </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>) &#123;            </span><br><span class="line">                n = <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</span><br><span class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27;\n&#x27;</span>)) &#123;               </span><br><span class="line">                    <span class="built_in">recv</span>(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                            </span><br><span class="line">                    c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;       </span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受新连接处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_accept</span><span class="params">(<span class="type">int</span> lfd, <span class="type">int</span> epfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印客户端信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;New Client IP: %s, Port: %d, cfd = %d\n&quot;</span>,</span><br><span class="line">           <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr.s_addr, ip, <span class="built_in">sizeof</span>(ip)),</span><br><span class="line">           <span class="built_in">ntohs</span>(client.sin_port), cfd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置cfd为非阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到的新节点挂到epoll树上</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    <span class="comment">// 边沿非阻塞模式</span></span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123; </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_listen_fd</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> epfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//　创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lfd绑定本地IP和port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    serv.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv, <span class="built_in">sizeof</span>(serv));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;    </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lfd添加到epoll树上</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add lfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 16进制数转化为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexit</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  这里的内容是处理%20之类的东西！是&quot;解码&quot;过程。</span></span><br><span class="line"><span class="comment"> *  %20 URL编码中的‘ ’(space)</span></span><br><span class="line"><span class="comment"> *  %21 &#x27;!&#x27; %22 &#x27;&quot;&#x27; %23 &#x27;#&#x27; %24 &#x27;$&#x27;</span></span><br><span class="line"><span class="comment"> *  %25 &#x27;%&#x27; %26 &#x27;&amp;&#x27; %27 &#x27;&#x27;&#x27; %28 &#x27;(&#x27;......</span></span><br><span class="line"><span class="comment"> *  相关知识html中的‘ ’(space)是&amp;nbsp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tolen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tolen = <span class="number">0</span>; *from != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; tolen + <span class="number">4</span> &lt; tosize; ++from) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalnum</span>(*from) || <span class="built_in">strchr</span>(<span class="string">&quot;/_.-~&quot;</span>, *from) != (<span class="type">char</span>*)<span class="number">0</span>) &#123;      </span><br><span class="line">            *to = *from;</span><br><span class="line">            ++to;</span><br><span class="line">            ++tolen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(to, <span class="string">&quot;%%%02x&quot;</span>, (<span class="type">int</span>) *from &amp; <span class="number">0xff</span>);</span><br><span class="line">            to += <span class="number">3</span>;</span><br><span class="line">            tolen += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; *from != <span class="string">&#x27;\0&#x27;</span>; ++to, ++from  ) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>])) &#123;       </span><br><span class="line">            *to = <span class="built_in">hexit</span>(from[<span class="number">1</span>])*<span class="number">16</span> + <span class="built_in">hexit</span>(from[<span class="number">2</span>]);</span><br><span class="line">            from += <span class="number">2</span>;                      </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过文件名获取文件的类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* dot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);   </span><br><span class="line">    <span class="keyword">if</span> (dot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>( dot, <span class="string">&quot;.wav&quot;</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 命令行参数获取 端口 和 server提供的目录</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;./server port path\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取用户输入的端口 </span></span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改变进程工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">chdir</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 epoll监听</span></span><br><span class="line"><span class="built_in">epoll_run</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络|c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开放词汇视觉感知</title>
      <link href="/2024/05/28/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/"/>
      <url>/2024/05/28/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>2024.6.2</p><ul><li>本周:学习了开放词汇的思想概念,并针对开放词汇分类和部分开放词汇检测模型检索学习主体框架思想.</li><li>下周预期目标:继续学习开放词汇检测模型和了解学习词汇分割(之前没接触过这一部分)</li></ul><p>2024.6.7</p><p><a href="https://b23.tv/err4EvJ?share_medium=android&share_source=qq&bbid=XY8675383E088DF9060D7760F32782495A44E&ts=1716510410958">报告链接分享</a></p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>传统视觉感知模型在开放场景中，无法完成对陌生类别的正确识别</p><p>对于开放场景的多种任务类型</p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/mul_task.png" alt="为应对开放场景中的挑战，多种任务类型被提出"></p><h2 id="open-Set-Recognition"><a href="#open-Set-Recognition" class="headerlink" title="open-Set Recognition"></a>open-Set Recognition</h2><p><a href="https://arxiv.org/pdf/1812.04246v2">论文原文</a></p><ul><li><p>训练集中的类别和测试集中的类别是一致的，最常见的就是使用公开数据集进行训练，所有数据集中的图像的类别都是已知的，没有未知种类的图像。传统的机器学习的算法在这些任务上已经取得了比较好的效果。</p></li><li><p>现实场景中更多的是开放和非静态的环境，比如，一些没有见过的情况会意外出现。</p></li><li><p>开集识别简单定义是，一个在训练集上训练好的模型，当利用一个测试集（该测试集的中包含训练集中没有的类别）进行测试时，如果输入已知类别数据，输出具体的类别，如果输入的是未知类别的数据，则进行合适的处理（识别为unknown）。</p></li><li><p>示例 : </p><ul><li>猫狗识别模型，输入一张荷花或者大象的图像，模型可能会告诉你80% 的概率为 猫。</li><li>想要的结果 : 输入不为猫狗的图像，模型输出为未知类别，输入猫狗图像，模型输出对应具体的类别</li></ul></li></ul><h2 id="Few-Shot-Learning"><a href="#Few-Shot-Learning" class="headerlink" title="Few-Shot Learning"></a>Few-Shot Learning</h2><p><a href="https://arxiv.org/pdf/1904.05046">该文章总结166篇参考文献阐述了什么是少样本学习</a></p><p>整体主题</p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/FSL.png"></p><ul><li>利用先验知识从数据,模型,算法角度处理问题</li></ul><h2 id="Zero-Shot-Learning"><a href="#Zero-Shot-Learning" class="headerlink" title="Zero-Shot Learning"></a>Zero-Shot Learning</h2><p><a href="https://dl.acm.org/doi/abs/10.1145/3293318">完整介绍</a></p><ul><li>简单阐述,零样本学习就是，在测试集中，有些类别不在训练集中，利用训练集的样本训练一个模型，使之应用到测试集能正确识别那些在训练集中不存在的标签。</li></ul><h2 id="Open-Vocabulary-Learning"><a href="#Open-Vocabulary-Learning" class="headerlink" title="Open Vocabulary Learning"></a>Open Vocabulary Learning</h2><ul><li>核心为从大规模数据提炼知识，并迁移到下游感知任务</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vac.png"></p><h1 id="开放词汇分类"><a href="#开放词汇分类" class="headerlink" title="开放词汇分类"></a>开放词汇分类</h1><ul><li>基本原理：利用海量图像-文本对，将图像与文本映射到同一嵌入空间，实现概念跨模态语义对齐</li><li>特点：<ul><li>图文关联弱，噪声较大</li><li>海量数据易获取</li><li>泛化能力强</li></ul></li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/compare_learn.png"></p><h2 id="CLIP"><a href="#CLIP" class="headerlink" title="CLIP"></a>CLIP</h2><ul><li>首个将Transformer、对比学习结合，从4亿互联网图文对数据集训练多模态图文匹配模型。</li><li></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>跨模态对齐</li><li>零样本预测能力</li><li>较强的泛化能力</li><li>大规模预训练</li></ul><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><ol><li>从数据集中选取Batch大小为N的图文对数据</li><li>分别经过图(Resnet or VIT)、文(Transformer)编码器转化成特征</li><li>学习图文多模态特征嵌入空间，使得可以在特征空间计算图文匹配相似性</li><li>计算两两图文之间的相似度，并用交叉熵函数(对称交叉熵)计算损失</li></ol><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip.png"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据集需要大量人工清理(互联网上的数据可能包含噪声、错误或不准确的描述。为了确保模型能够学习到准确的视觉和语言关联，需要人工清理和验证数据集，确保图像和文本描述是准确匹配的。)</li></ul><h2 id="ALIGN"><a href="#ALIGN" class="headerlink" title="ALIGN"></a>ALIGN</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>模型更大,需要更大数据集</li><li>采用自然图文对数据分布</li></ul><h2 id="预训练模型的迁移学习"><a href="#预训练模型的迁移学习" class="headerlink" title="预训练模型的迁移学习"></a>预训练模型的迁移学习</h2><ul><li>在实际应用中,我们需要将预训练模型迁移至下游识别任务,但如果直接完全微调预训练视觉语言模型需要大量的数据和计算资源,所以对预训练模型的迁移学习的研究十分有必要,这里作者给出两个方向对模型进行迁移学习</li></ul><h3 id="提示学习"><a href="#提示学习" class="headerlink" title="提示学习"></a>提示学习</h3><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/remind_learn.png"></p><h4 id="文本提示学习"><a href="#文本提示学习" class="headerlink" title="文本提示学习"></a>文本提示学习</h4><h5 id="CoOp"><a href="#CoOp" class="headerlink" title="CoOp"></a>CoOp</h5><p><a href="https://arxiv.org/abs/2109.01134">论文</a> <a href="https://github.com/KaiyangZhou/CoOp">代码</a></p><h6 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h6><ul><li>从手工提示进行改进,对提示模板进行学习,优化提示与句子之间的联系(将手工提示过程自动化)</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/CoOp.png"></p><h6 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h6><ul><li>使用一组可学习向量(learnable context)对提示词中的上下文进行建模，在训练中使用分类损失进行向量优化</li><li>使用更少的计算资源、训练数据和训练时间优化匹配</li></ul><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul><li>可学习的上下文极大影响模型对于未知类预测的泛化性,学习到的固定提示会过拟合于特定的类别集合</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/dis_CoOp.png"></p><h5 id="CoCoOp"><a href="#CoCoOp" class="headerlink" title="CoCoOp"></a>CoCoOp</h5><p><a href="https://arxiv.org/abs/2203.05557">论文</a> <a href="https://github.com/KaiyangZhou/CoOp">代码</a></p><h6 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h6><ul><li>使提示以每个输入实例（图像）为条件，动态预测，而非学习后固定</li><li>context tokens也可以由image embedding决定</li><li>$$ v_m(x) &#x3D; v_m + \pi $$</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/CoCoOp.png"></p><h6 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h6><ul><li>提示学习过程以对应实例为条件，不影响未知类别，增强泛化性</li></ul><h5 id="CuPL"><a href="#CuPL" class="headerlink" title="CuPL"></a>CuPL</h5><p><a href="https://arxiv.org/abs/2209.03320v1">论文</a> <a href="https://github.com/sarahpratt/CuPL">代码</a></p><h6 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h6><ul><li>引入大语言模型的回答作为文本的prompt进行分类</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/CuPL.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/CuPL_prompts.png"></p><h6 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h6><ul><li>性能的提升随着使用的LLM提示和图像提示的增加而增大</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/LLM.png"></p><h4 id="视觉提示学习"><a href="#视觉提示学习" class="headerlink" title="视觉提示学习"></a>视觉提示学习</h4><ul><li>在视觉主干网络（图像编码器）引入提示学习,优化图像特征</li></ul><h5 id="VPT"><a href="#VPT" class="headerlink" title="VPT"></a>VPT</h5><p><a href="https://arxiv.org/abs/2203.12119">论文</a> <a href="https://github.com/kmnp/vpt">代码</a></p><h6 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h6><ul><li>图像Transformer编码层输入序列插入可学习提示参数</li><li>训练过程中冻结主干网络参数，只微调新增的提示参数</li></ul><h6 id="VPT-Shallow"><a href="#VPT-Shallow" class="headerlink" title="VPT-Shallow"></a>VPT-Shallow</h6><ul><li>只在第一个编码层插入提示</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vpt-shallow-formula.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vpt-shallow.png"></p><h6 id="VPT-Deep"><a href="#VPT-Deep" class="headerlink" title="VPT-Deep"></a>VPT-Deep</h6><p><a href="https://arxiv.org/abs/2304.08386">论文</a></p><ul><li>在每一个编码层的输入序列插入提示</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vpt-deep-formula.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vpt-deep.png"></p><h5 id="DAM-VP"><a href="#DAM-VP" class="headerlink" title="DAM-VP"></a>DAM-VP</h5><p><a href="https://arxiv.org/abs/2303.08138">论文</a> <a href="https://github.com/shikiw/DAM-VP">代码</a></p><h6 id="思想-4"><a href="#思想-4" class="headerlink" title="思想"></a>思想</h6><ul><li>数据集多样性感知提示策略，并使用元提示进行初始化</li><li>将下游数据集分成小的同质子集,并对每个子集分别优化</li></ul><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><ul><li>训练<ul><li>给定下游数据集，随机选取一个子集输入无提示的模型提取特征，并执行聚类；类别数量由预定义阈值根据多样性程度定义。每个聚簇对应一个视觉提示</li></ul></li><li>测试<ul><li>使用无提示模型生成特征并寻找聚类中心，获得对应的提示进行推理</li></ul></li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/dam-vp.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/DAM-VP-f.png"></p><h4 id="多模态提示学习"><a href="#多模态提示学习" class="headerlink" title="多模态提示学习"></a>多模态提示学习</h4><h5 id="MaPLe"><a href="#MaPLe" class="headerlink" title="MaPLe"></a>MaPLe</h5><p><a href="https://arxiv.org/abs/2210.03117">论文</a> <a href="https://github.com/muzairkhattak/multimodal-prompt-learning">代码</a></p><h6 id="思想-5"><a href="#思想-5" class="headerlink" title="思想"></a>思想</h6><ul><li>在文本和图像编码器的前J层（总层数为K）分别加上额外可学习提示，剩下K-J层的提示编码来自上一层的输出。</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/maple.png"></p><h6 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h6><ul><li>引入使用J个耦合函数（线性层）将文本提示转换为视觉提示，即视觉提示由文本提示生成</li><li>共享可学习嵌入空间，促进模态间协同优化</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/maple-formula.png"></p><h3 id="特征适配器"><a href="#特征适配器" class="headerlink" title="特征适配器"></a>特征适配器</h3><h4 id="CLIP-adapter"><a href="#CLIP-adapter" class="headerlink" title="CLIP-adapter"></a>CLIP-adapter</h4><p><a href="https://arxiv.org/abs/2110.04544">论文</a> <a href="https://github.com/gaopengcuhk/clip-adapter">代码</a></p><h5 id="思想-6"><a href="#思想-6" class="headerlink" title="思想"></a>思想</h5><ul><li>只微调额外添加的轻量特征适配器，该适配器通常被加在文本和视觉编码器之后</li></ul><h5 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h5><ul><li>与CoOp相比<ul><li>CoOp: 可学习的提示置于文本或视觉编码器之前， 需要正向和反向传播文本&#x2F;图像编码器梯度</li><li>CLIP-adapter: 特征适配器置于文本与视觉编码器之后，不需要传播编码器的梯度，提升优化效率</li></ul></li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip-adapter.png"></p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/clip-ada.png"></p><ul><li>双层感知机</li><li>残差融合<br><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/adapter-formula.png"><br><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/adapter-formula-f.png"></li></ul><h4 id="ETRIS"><a href="#ETRIS" class="headerlink" title="ETRIS"></a>ETRIS</h4><p><a href="https://arxiv.org/pdf/2209.00068">论文</a> <a href="https://github.com/kkakkkka/ETRIS">代码</a></p><h5 id="思想-7"><a href="#思想-7" class="headerlink" title="思想"></a>思想</h5><ul><li>设计新的桥接器模块可以无缝集成到经典的双编码器视觉语言预训练模型以增强跨模态融合（通用、兼容）。</li><li>设计轻量化的解码器，实现视觉语言特征的多尺度对齐。</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><ul><li>Bridger：包含Zoom Layer调节特征尺寸，所得特征输入交互器进行融合</li><li>Zoom Layer：卷积和反卷积</li><li>交互器：自注意力模块和交叉注意力模块</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/ETRIS.png"></p><h4 id="TIP-adapter"><a href="#TIP-adapter" class="headerlink" title="TIP-adapter"></a>TIP-adapter</h4><p><a href="https://arxiv.org/abs/2111.03930">论文</a> <a href="https://github.com/gaopengcuhk/Tip-Adapter">代码</a></p><h5 id="思想-8"><a href="#思想-8" class="headerlink" title="思想"></a>思想</h5><ul><li>探索一种无需训练的模型迁移范式</li><li>基于小样本数据集设计查询-键值缓存来实现</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/TIP-ADAPTER.png"></p><ul><li>将小样本图像的CLIP视觉编码器特征作为缓存中的key，将对应类别标签作为Value存储。</li><li>推理阶段，获取图像CLIP视觉编码器特征作为Query，生成对应的关系向量：<br><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/tip-adapter-f1.png"></li><li>图像分类预测由关系向量A和Value的点积及CLIP分类器的结果加权：<br><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/tip-adapter-f2.png"></li></ul><h4 id="TIP-adapter-F"><a href="#TIP-adapter-F" class="headerlink" title="TIP-adapter-F"></a>TIP-adapter-F</h4><h5 id="思想-9"><a href="#思想-9" class="headerlink" title="思想"></a>思想</h5><ul><li>针对TIP-adapter做出改进,将缓存设置为可学习向量，并用原本的OneHot向量作为初始化，微调提升性能</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/tip-adapter-f.png"></p><h1 id="开放词汇检测"><a href="#开放词汇检测" class="headerlink" title="开放词汇检测"></a>开放词汇检测</h1><ul><li>学习范式：从自然图文对数据中获取开放类别知识，从区域级监督数据中学习目标检测</li></ul><h2 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h2><h3 id="OVR-CNN"><a href="#OVR-CNN" class="headerlink" title="OVR-CNN"></a>OVR-CNN</h3><p><a href="https://ieeexplore.ieee.org/document/9577418">论文</a> <a href="https://github.com/alirezazareian/ovr-cnn">代码</a></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/ovr-cnn.png"></p><h4 id="思想-10"><a href="#思想-10" class="headerlink" title="思想"></a>思想</h4><ul><li><p>Learning Visual Semantic Space:</p><ul><li>利用image-caption数据预训练backbone以获取开放词汇知识</li></ul></li><li><p>Learning Open-Vocabulary Detection:</p><ul><li>利用目标检测监督数据微调检测模型</li></ul></li></ul><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><h5 id="Pre-training"><a href="#Pre-training" class="headerlink" title="Pre-training"></a>Pre-training</h5><ul><li>Image (w*h)输入resnet50 backbone，提取区域的视觉特征(w&#x2F;32*h&#x2F;32)，并使用全连接层 (V2L) 将其转换到文本特征空间</li><li>基于Caption提取文本特征。视觉特征与文本特征间计算弱监督形式的Grounding Loss</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/ovr-cnn-pre.png"></p><h5 id="Detection-Training"><a href="#Detection-Training" class="headerlink" title="Detection Training"></a>Detection Training</h5><ul><li>基于预训练的backbone，V2L层与embedding层构建检测器</li><li>利用仅包含基础类的物体检测数据集对检测器进行监督训练</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/ovr-cnn-detec.png"></p><h3 id="RegionCLIP"><a href="#RegionCLIP" class="headerlink" title="RegionCLIP"></a>RegionCLIP</h3><p><a href="https://arxiv.org/pdf/2112.09106">论文</a> <a href="https://github.com/microsoft/RegionCLIP">代码</a></p><ul><li>CLIP 模型的训练是使用整个image作为输入的，使用的是image-level的文本描述来训练的，所以，模型学习到的是整张图的特征</li><li>这种模型无法将文本概念和图像中的区域联系起来</li></ul><h4 id="思想-11"><a href="#思想-11" class="headerlink" title="思想"></a>思想</h4><ul><li>借助CLIP模型进行区域级图文匹配预训练</li></ul><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><ul><li>利用RCN构造region伪标签与image-text 一起预训练</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/region-clip.png"></p><h3 id="GLIP"><a href="#GLIP" class="headerlink" title="GLIP"></a>GLIP</h3><p><a href="https://arxiv.org/abs/2112.03857">论文</a> <a href="https://github.com/microsoft/GLIP">代码</a></p><h4 id="思想-12"><a href="#思想-12" class="headerlink" title="思想"></a>思想</h4><ul><li>将物体匹配与短语定位任务统一起来进行预训练</li><li>利用区域定位能力从图文对数据中构建准确的区域文本对数据</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/glip.png"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><ul><li>利用已有的Grounding数据（80万）进行监督训练，得到教师模型</li><li>从图像文本对数据提取名词短语，基于“教师-学生”半监督学习从“图像文本对”生成“区域文本对”伪标签，并加入训练学生模型。</li></ul><h3 id="Grounding-DINO"><a href="#Grounding-DINO" class="headerlink" title="Grounding-DINO"></a>Grounding-DINO</h3><p><a href="https://arxiv.org/abs/2303.05499v4">论文</a> <a href="https://github.com/IDEA-Research/GroundingDINO">代码</a></p><ul><li>更强的检测器架构：基于Transformer Detector DINO进行预训练</li><li>更细粒度的多模态特征融合：特征编码、query初始化、特征解码三个层面的特征融合</li><li>更强的Grounding能力：支持Referring Expression Comprehension（REC）</li></ul><h4 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h4><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/grouding-dino-featrues.png"></p><h3 id="VL-PLM"><a href="#VL-PLM" class="headerlink" title="VL-PLM"></a>VL-PLM</h3><h4 id="思想-13"><a href="#思想-13" class="headerlink" title="思想"></a>思想</h4><ul><li>借助视觉语言预训练模型为无标注图像构造“区域-文本”伪标签，训练物体检测器</li></ul><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vl-plm.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vl-plm-tag.png"></p><h3 id="MarvelOVD"><a href="#MarvelOVD" class="headerlink" title="MarvelOVD"></a>MarvelOVD</h3><h4 id="思想-14"><a href="#思想-14" class="headerlink" title="思想"></a>思想</h4><ul><li>弥补视觉语言模型在区域推理中由于领域差异造成的噪声标签问题（伪标签不准确）</li><li>检测器具备上下文特征提取能力与背景概念，动态结合检测器性质以弥补领域差异</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/marvalovd-think.png"></p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/marvalovd-1.png"></p><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/marvalovd-2.png"></p><h3 id="GenerateU"><a href="#GenerateU" class="headerlink" title="GenerateU"></a>GenerateU</h3><h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><h3 id="ViLD"><a href="#ViLD" class="headerlink" title="ViLD"></a>ViLD</h3><p><a href="https://arxiv.org/abs/2104.13921">论文</a> </p><h4 id="思想-15"><a href="#思想-15" class="headerlink" title="思想"></a>思想</h4><ul><li>基于标注框及RPN生成的检测框截取局部图像，输入CLIP 图像编码器提取视觉表征</li><li>添加L1损失，使检测器的ROI特征对齐CLIP特征</li><li>对齐特征既包括基础类别，也包括图像中潜在的开放类别物体</li></ul><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vild-think.png"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p><img src="/../images/%E5%BC%80%E6%94%BE%E8%AF%8D%E6%B1%87%E8%A7%86%E8%A7%89%E6%84%9F%E7%9F%A5/vild.png"></p><h3 id="LBP"><a href="#LBP" class="headerlink" title="LBP"></a>LBP</h3><h4 id="思想-16"><a href="#思想-16" class="headerlink" title="思想"></a>思想</h4><ul><li>提出针对背景框更好的表征学习方案，挖掘潜在开放类别</li></ul><h3 id="F-VLM"><a href="#F-VLM" class="headerlink" title="F-VLM"></a>F-VLM</h3><h1 id="开放词汇分割"><a href="#开放词汇分割" class="headerlink" title="开放词汇分割"></a>开放词汇分割</h1><h1 id="下游任务应用"><a href="#下游任务应用" class="headerlink" title="下游任务应用"></a>下游任务应用</h1><h1 id="多模态大模型"><a href="#多模态大模型" class="headerlink" title="多模态大模型"></a>多模态大模型</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习|计算机视觉|多模态大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2024/03/20/C/"/>
      <url>/2024/03/20/C/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><ol><li>加号、左移运算符重载</li></ol><ul><li>格式： 类名 &amp; operator（类名 &amp; p）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a += p.a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b += p.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般利用全局函数重载&lt;&lt;运算符</span></span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; p.a &lt;&lt; endl &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; p.b &lt;&lt; endl;*/</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">12</span>,<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(p1 + p2)</span></span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自增运算符重载</li></ol><p>c++对自增运算符做出如下定义：</p><ul><li>前置自增<br>类名 &amp; operator++()</li><li>后置自增<br>类名 operator++(int)<br>此处不加引用是为了配合后置自增的固有特性<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Interger a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Interger</span>(<span class="type">int</span> a) :<span class="built_in">m_A</span>(a) &#123;&#125;</span><br><span class="line">Interger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">m_A++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Interger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">Interger tmp = *<span class="keyword">this</span>;</span><br><span class="line">++m_A;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Interger a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a.m_A;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Interger a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ++a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>赋值运算符重载</li></ol><ul><li>核心就是注意当成员变量是堆区的数据的话，要注意内存的释放时机（也就是要注意深浅拷贝）</li><li>格式： 类名 &amp; operator&#x3D;（类名 &amp; p） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="keyword">new</span> <span class="built_in">int</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_A != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_A;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_A);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_A != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_A;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_A != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_A;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_A);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *p.m_A;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">Person p2 = <span class="number">5</span>;</span><br><span class="line">p2 = p1;</span><br><span class="line">cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">Person p3 = p2;</span><br><span class="line">cout &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>关系运算符重载</li></ol><ul><li>格式：bool operator（类名&amp; p）</li></ul><ol start="5"><li>函数调用运算符重载</li></ol><ul><li>格式：返回类型 operator（）（参数）</li><li>非常灵活，其被类重载的类也为反函数  </li><li>匿名函数对象 类名（）</li></ul><h3 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>语法： class 子类 ： 继承方式 父类</li><li>继承方式<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共性：父类中private属性均不能访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">protected</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> :<span class="keyword">private</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>继承中的对象模型：父类中的所有对象属性都属于子类<br>利用开发人员命令提示工具查看对象模型：</li></ul><ol><li>跳转盘符 D：</li><li>跳转文件路径 cd 具体路径下</li><li>查看命名 cl &#x2F;d1 reportSingleClassLayout类名 文件名</li></ol><ul><li><p>继承中同名成员处理方式<br>  需添加作用域 例如：son.father::m_A<br>  &#x3D;&#x3D;注意点：当父类中出现与子类相同的同名函数，子类调用时会覆盖掉父类中所有的同名函数&#x3D;&#x3D;</p></li><li><p>多继承方式</p><p>class 子类 ： 属性 父类1，属性 父类2 ….</p></li><li><p>菱形继承</p></li></ul><ol><li>当菱形继承，两个父类拥有相同数据，需要加以作用域区分</li><li>只需一份数据即可（利用虚继承解决）<ul><li>继承之前加上 virtual</li></ul></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p>动态多态满足条件</p><ol><li>有继承关系</li><li>子类重写父类的虚函数</li><li>父类的指针或者引用执行子类对象</li></ol></li><li><p>纯虚函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当使用纯虚函数时，该类称为抽象类，子类必须实现该函数，否则子类也为抽象类</p></li><li><p>虚析构和纯虚析构（解决父类指针释放子类内存）<br>  都需要具体实现</p></li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="写文件和读文件"><a href="#写文件和读文件" class="headerlink" title="写文件和读文件"></a>写文件和读文件</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">//第一步</span></span></span><br><span class="line"></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out); <span class="comment">//第二步</span></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;hello word&quot;</span>; <span class="comment">//第三步</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">ifstream ifs; <span class="comment">//第二步</span></span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in); <span class="comment">//第三步</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件的四种操作</span></span><br><span class="line">string str;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(s,<span class="built_in">sizeof</span>(s)))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(ifs,str))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="keyword">while</span> ((ch = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后不要忘记关文件</span></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><ul><li>写文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">Person p = &#123; <span class="number">18</span>,<span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)  &amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>读文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>(( <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; p.age  &lt;&lt; endl &lt;&lt; p.str &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><h2 id="c-泛型编程和stl"><a href="#c-泛型编程和stl" class="headerlink" title="c++ 泛型编程和stl"></a>c++ 泛型编程和stl</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//声明或定义</span></span><br></pre></td></tr></table></figure><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><h5 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h5><ol><li>普通函数可以发生隐式类型转换</li><li>函数模板用自动类型推导,不可以发生隐式类型转换</li><li>函数模板用显示指定类型,可以发生隐式类型转换</li></ol><h5 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;函数模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b= <span class="number">20</span>;</span><br><span class="line">myswap&lt;&gt;(a, b); <span class="comment">//优先调用函数模板</span></span><br></pre></td></tr></table></figure></li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> b= <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myswap</span>(a, b); <span class="comment">//优先调用函数模板</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h5><ul><li>有些特定的数据类型,需要你具体化做特殊实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt;= b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体情况具体分析</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Person a,Person b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.age &gt;= b.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h5><ul><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Age</span> = <span class="type">int</span>,<span class="keyword">class</span> Name&gt; <span class="comment">//</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="类模板和普通成员函数的调用时机"><a href="#类模板和普通成员函数的调用时机" class="headerlink" title="类模板和普通成员函数的调用时机"></a>类模板和普通成员函数的调用时机</h5><ul><li>类模板中成员函数时才去创建<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下程序剋通过编译</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2&quot;</span> &lt;&lt;  endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一旦创建后这段代码便不能通过编译</span></span><br><span class="line">MyClass&lt;Person1&gt; myclass;</span><br><span class="line">myclass.<span class="built_in">func2</span>();</span><br></pre></td></tr></table></figure><h5 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h5><ul><li>当子类继承的父类是一个类模板时,子类在声明的时候,要指出父类T的类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base <span class="comment">//错误</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//正确</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;T1&gt; <span class="comment">//正确</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>如果想灵活指定出父类中T的类型,子类也需变为类模板</li></ul><h5 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h5><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li><li>解决方法：<ol><li>直接包含。cpp源文件</li><li>将声明和实现写到同一个文件中，改后缀名为.hpp</li></ol></li></ul><h5 id="全局函数类外实现"><a href="#全局函数类外实现" class="headerlink" title="全局函数类外实现"></a>全局函数类外实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(Person&lt;T&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//加空模板的参数列表，告诉编译器这是模板函数的声明i二位我就觉得撒娇了；</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(Person&amp; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() :<span class="built_in">m_Age</span>(<span class="number">5</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="built_in">show</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>remove(int val) 移除所有等于val的元素</li><li>reverse() 反转操作</li><li>由于不支持随机访问，所以不能调用标准排序算法库，可以使用内置的sort库</li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>插入只能用insert</li><li>erase(int val) 删除值为val的元素</li><li>find(key) 返回指针，若没找到返回end()</li><li>count(key)</li><li>可利用仿函数指定排序规则</li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><h5 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h5><ul><li>仿函数返回类型是bool数据类型，称为谓词</li></ul><h5 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/03/20/Java/"/>
      <url>/2024/03/20/Java/</url>
      
        <content type="html"><![CDATA[<p>省略许多很基础的东西，主要记录一些Java语言特有的特性，未更完…</p><h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><h6 id="1-断点调试"><a href="#1-断点调试" class="headerlink" title="1. 断点调试"></a>1. 断点调试</h6><ul><li>快捷键介绍:<ul><li>F7(跳入) <em>如果不成功，可通过File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger -&gt; Stepping</em>,将java.*和javax.*强制取消勾选</li><li>F8(跳过) </li><li>shift + F8(跳出) </li><li>F9(resume,执行到下一个断点)</li></ul></li></ul><h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><h5 id="1-JDK与JRE"><a href="#1-JDK与JRE" class="headerlink" title="1. JDK与JRE"></a>1. JDK与JRE</h5><ul><li>JDK&#x3D;JRE+开发工具集(javac,java编译工具等)</li><li>JRE&#x3D;JVM+JAVA SE标准类库(java核心类库)</li><li>注:如果只是想运行开发好的.class文件,只需JRE</li></ul><h5 id="2-文档注释"><a href="#2-文档注释" class="headerlink" title="2. 文档注释"></a>2. 文档注释</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> baiyue</span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法：javadoc -d 生成的文件名 -version -author xxx.java</p><h5 id="3-Java中的变量细节"><a href="#3-Java中的变量细节" class="headerlink" title="3. Java中的变量细节"></a>3. Java中的变量细节</h5><p>转换机制：有两条。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(char)--&gt;b(int)--&gt;c(long)--&gt;d(float)--&gt;e(double)</span><br><span class="line">f(byte)--&gt;s(short)--&gt;b</span><br></pre></td></tr></table></figure><p><em>细节</em></p><ul><li>基本满足小到大可自动转换，大到小就不行</li><li>当有多种数据类型混和运算时，转换为最大的数据类型</li><li>byte short 和char之间不能相互自动转换,例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b1=<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c1=b1;<span class="comment">//错误,之间不能自动转换</span></span><br></pre></td></tr></table></figure></li><li>byte,short,char 他们三者可以计算,在计算时首先转换为int型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> b2 + s1;<span class="comment">//错误,b2+s1 =&gt; int</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> b3 + b2;<span class="comment">//非常容易忽略,原理同上,b2+b3会自动转换为int</span></span><br><span class="line"><span class="type">short</span> s=s1+<span class="number">1</span>;<span class="comment">//错误,s1+1为int类型</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="4-强制数据类型转换"><a href="#4-强制数据类型转换" class="headerlink" title="4. 强制数据类型转换"></a>4. 强制数据类型转换</h5><p><em>细节</em>(阐述的都是一些容易犯错的细节)</p><ul><li>char类型可以保存int常量型,但不能保存int变量值,需要强转<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c1=<span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2=m;<span class="comment">//false</span></span><br><span class="line"><span class="type">char</span> c3=<span class="type">char</span>(m);<span class="comment">//ok,输出100ASCIll对应的字符</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="5-java中的运算符细节"><a href="#5-java中的运算符细节" class="headerlink" title="5. java中的运算符细节"></a>5. java中的运算符细节</h5><ul><li>在取模运算中,Java与c有不同,c只能对整数取模,而java可以对小数取模,例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=-<span class="number">10.5</span>%<span class="number">3</span>;<span class="comment">//c中会报错,而在Java中显示-1.5,当然精度会有所损失</span></span><br></pre></td></tr></table></figure></li><li>自增运算符i++理解&lt;&#x3D;&#x3D;&gt;temp&#x3D;i;i&#x3D;i+1;temp&#x3D;i;<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">i=i++;<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="6-进制表示"><a href="#6-进制表示" class="headerlink" title="6. 进制表示"></a>6. 进制表示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1=<span class="number">1010</span>;  <span class="comment">//1010 十进制</span></span><br><span class="line"><span class="type">int</span> n2=<span class="number">01010</span>; <span class="comment">//520 8进制</span></span><br><span class="line"><span class="type">int</span> n3=<span class="number">0b1010</span>; <span class="comment">//10 2进制 </span></span><br><span class="line"><span class="type">int</span> n4=<span class="number">0x1010</span>; <span class="comment">//4112 16进制</span></span><br><span class="line">System.out.println(n1+<span class="string">&quot;\n&quot;</span>+n2+<span class="string">&quot;\n&quot;</span>+n3+<span class="string">&quot;\n&quot;</span>+n4);</span><br></pre></td></tr></table></figure><p>三元运算符细节：把整个看成一个整体</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>?<span class="number">1</span>:<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//a = 1.0;</span></span><br></pre></td></tr></table></figure><h5 id="6-关于数组"><a href="#6-关于数组" class="headerlink" title="6. 关于数组"></a>6. 关于数组</h5><p>&#x3D;&#x3D;与c不同，java的数组是引用类型，本质是对象，所以有自己的赋值机制。&#x3D;&#x3D;</p><ul><li>在而二维数组中,每行的列数可不等,这里比较灵活,例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">a[i]=<span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">a[i][j]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a[i].length;++j)&#123;</span><br><span class="line">System.out.println(a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:  1</span></span><br><span class="line"><span class="comment">//       2 2</span></span><br><span class="line"><span class="comment">//       3 3 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>还需注意二维数组的声明方式有</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][];</span><br><span class="line"><span class="type">int</span>[] a[];</span><br><span class="line"><span class="type">int</span>[][] a;</span><br></pre></td></tr></table></figure><p>这就会产生一些细节问题,如以下代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] x,y[];<span class="comment">//x是一维数组,y是二维数组</span></span><br></pre></td></tr></table></figure><p>对string数组的声明细节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="一-Java初级"><a href="#一-Java初级" class="headerlink" title="一. Java初级"></a>一. Java初级</h4><h6 id="关于方法重载注意事项"><a href="#关于方法重载注意事项" class="headerlink" title="关于方法重载注意事项"></a>关于方法重载注意事项</h6><ol><li>函数名必须相同</li><li>返回类型无要求</li><li>形参列表至少有一项不同</li></ol><h6 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h6><ul><li>Java中允许将同一个类中多个同名但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HspMethod</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">res+=nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. int... 表示接收的是可变参数,类型是int,既可以接收多个int(0-多)</span></span><br><span class="line"><span class="comment">//2. 使用可变参数是,应该当作数组使用</span></span><br></pre></td></tr></table></figure></li><li><em>注意细节</em></li></ul><ol><li>可变参数的实参可以是0或任意多个</li><li>可变参数的实参可以为数组</li><li>一个形参列表只能有一个可变参数</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数放在最后</li></ol><h6 id="关于作用域"><a href="#关于作用域" class="headerlink" title="关于作用域"></a>关于作用域</h6><p>在java中，全局变量一般指属性，而局部变量一般指方法中定义的变量。<br><em>一个小细节，全局变量可以不赋值，直接使用；而局部变量必须赋值后，才能使用，因为没有默认值</em></p><h6 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h6><ul><li><em>注意细节</em></li></ul><ol><li>如果使用者没有定义构造方法，系统会自动生成一个默认无参的构造方法（也称为默认构造方法）&#x3D;&#x3D;可以使用javap指令反编译查看&#x3D;&#x3D;</li><li>一旦定义自己的构造器，<strong>系统默认的构造器会被覆盖</strong>，无法使用默认构造器，除非再进行显示定义（构造器重载原理）</li></ol><h6 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h6><ul><li>注意细节</li></ul><ol><li>this可以访问本类的属性、方法、构造器</li><li>访问成员变量的语法：this.（方法名）</li><li>访问构造器的语法:this(参数列表)(注意只能在构造器中使用)<br> <em>即只能在构造器中访问另一个构造器</em> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><em>注：必须放置第一条语句</em></li></ul><ol start="4"><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><h4 id="二-java中级"><a href="#二-java中级" class="headerlink" title="二. java中级"></a>二. java中级</h4><h6 id="1-包"><a href="#1-包" class="headerlink" title="1. 包"></a>1. 包</h6><ul><li><p>命名规则：只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo.class.exec1<span class="comment">//false,class is key word</span></span><br><span class="line">demo.12a <span class="comment">//false,12a is started with number</span></span><br><span class="line">demo.ab12.oa <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>命名规范:一般是小写字母加小圆点<br><em>com.公司名.项目名.业务模块名</em>,例如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sina.crm.user <span class="comment">//用户模块</span></span><br><span class="line">com.sina.crm.order<span class="comment">//订单模块</span></span><br><span class="line">com.sina.crm.utils<span class="comment">//工具类</span></span><br></pre></td></tr></table></figure></li><li><p>Java中常用的包:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang <span class="comment">//基本包,默认引入</span></span><br><span class="line"><span class="number">2.</span> java.util <span class="comment">//系统提供的工具包,工具类,使用Scanner</span></span><br><span class="line"><span class="number">3.</span> java.net <span class="comment">//网络包,网络开发</span></span><br><span class="line"><span class="number">4.</span> java.awt <span class="comment">//java的界面开发</span></span><br></pre></td></tr></table></figure></li><li><p>使用细节</p><ol><li>package的作用是声明当前类所在的包,需要放在类的<strong>最上面</strong>,一个类最多只有一句package</li><li>import指令放在package的下面,类定义前,顺序无要求</li></ol></li></ul><h6 id="2-访问修饰符"><a href="#2-访问修饰符" class="headerlink" title="2. 访问修饰符"></a>2. 访问修饰符</h6><table><thead><tr><th>1</th><th>访问级别</th><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>2</td><td>公开</td><td>public</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>3</td><td>受保护</td><td>protected</td><td>✔</td><td>✔</td><td>✔</td><td>x</td></tr><tr><td>4</td><td>默认</td><td>无</td><td>✔</td><td>✔</td><td>x</td><td>x</td></tr><tr><td>5</td><td>私有</td><td>private</td><td>✔</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><ul><li>注意事项<br>1. 只有默认和public可以修饰类,并且遵循上述访问权限的特点<br>2. 成员方法的访问规则和属性完全一样</li></ul><h6 id="3-封装-encapsulation"><a href="#3-封装-encapsulation" class="headerlink" title="3. 封装(encapsulation)"></a>3. 封装(encapsulation)</h6><ul><li><p>实现步骤</p><ol><li>将属性直接私有化(不能直接修改属性)</li><li>提供一个公共的(public)set方法,用于对属性判断并赋值 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXxx</span><span class="params">(类型 参数名)</span>&#123;</span><br><span class="line"> <span class="comment">//加入数据验证的逻辑</span></span><br><span class="line"> 属性=参数名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>提供一个公共的get方法,用于获取属性的值 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> XX <span class="title function_">getXxx</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//权限判断</span></span><br><span class="line"> <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>当使用构造器时，可以将方法调用写入构造器中，以维护其封装性</p></li></ul><h6 id="4-继承-extends"><a href="#4-继承-extends" class="headerlink" title="4. 继承(extends)"></a>4. 继承(extends)</h6><p><em>细节问题</em></p><ul><li><p>子类构造器第一句话为super()</p></li><li><p>子类继承了父类的所有属性和方法,但私有属性和方法不能在子类直接访问,要通过<strong>父类提供的公共方法</strong></p></li><li><p>子类必须调用父类的构造器,完成父类的初始化.并且父类没有提供无参构造器,则必须在子类的构造器中用<strong>super</strong>去指定使用父类的哪个构造器完成对父类的初始化工作,否则编译不通过.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.entend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.entend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;我必须存在&quot;</span>);<span class="comment">//当父类没有无参构造器时，必须使用super指明调用父类的哪个构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果指定需要调用哪个构造器，那就显式调用一下</p></li><li><p><strong>super必须放在子类的第一行</strong></p></li><li><p>由于super()和this()都只能放在构造器内部第一行，所以两者不能同时使用</p></li><li><p>所有的类都继承自Object类</p></li><li><p>子类最多只能继承一个父类(指直接继承),即java是单继承机制</p></li><li><p>当类属性名字相同时，优先访问最近的祖先，如果期间有private，就会报错，不会跳过继续向上寻找</p></li><li><p>关于super</p><ul><li>当子类中有和父类中的成员(属性和方法)重名时,为了访问父类的成员,必须通过super.如果没有重名,使用this和super时一样的效果,也可以直接访问</li></ul></li><li><p>方法重写</p><ul><li>子类的方法的参数，方法名称，和父类方法的参数，方法名称完全一样</li><li>子类的返回类型个父类的返回类型一样，或者是父类返回类型的子类(如父类的返回类型是Object,子类的返回类型是String)</li><li>子类方法不能缩小父类方法的访问权限<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> B <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;f方法被重写啦&quot;</span>);<span class="comment">//合理因为定义B是A的子类</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>*方法重写和重载比较</p><table><thead><tr><th>名称</th><th>发生范围</th><th>方法名</th><th>形参列表</th><th>返回类型</th><th>修饰符</th></tr></thead><tbody><tr><td>重载(overload)</td><td>本类</td><td>必须一样</td><td>类型,个数或者顺序至少有一个不同</td><td>无要求</td><td>无要求</td></tr><tr><td>重写(override)</td><td>父子类</td><td>必须一样</td><td>相同</td><td>子类重写的方法,返回类型和父类返回类型一致或者是其子类</td><td>子类方法不能缩小父类方法的访问范围</td></tr></tbody></table><h6 id="5-多态-polymorphic"><a href="#5-多态-polymorphic" class="headerlink" title="5. 多态(polymorphic)"></a>5. 多态(polymorphic)</h6><ul><li>多态的细节<ul><li>前提(两个对象(类)存在继承关系)</li><li>本质:父类的引用指向了子类的对象</li></ul></li></ul><p><strong>多态的向上转型</strong></p><ul><li>语法:父类类型 引用名 &#x3D; new 子类类型()</li><li>特点: <ol><li>可以调用父类所有成员(须遵循访问权限)</li><li>不能调用子类特有成员</li><li>最终运行效果看子类的具体实现,即调用方法时,按照子类(运行类型)开始查找方法,调用规则与之前一致</li></ol></li></ul><p><strong>多态的向下转型</strong></p><ul><li>语法:子类类型 引用名 &#x3D; (子类类型) 父类引用</li><li>只能强转父类的应用,不能强转父类的对象</li><li>要求父类的引用必须指向的是当前目标类型的对象</li><li>可以调用子类类型中所有的成员</li><li><strong>属性没有重写</strong>属性的值看编译类型!!!</li><li>instanceof,用于判断对象的运行类型是否为xx的子类型.</li></ul><p><strong>动态绑定机制</strong></p><ol><li>当调用对象方法的时候，该方法会会和该对象的内存地址&#x2F;运行类型绑定</li><li>当调用对象属性时，没有该机制，哪里声明哪里使用</li></ol><h6 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. &#x3D;&#x3D;运算符"></a>6. &#x3D;&#x3D;运算符</h6><ol><li>既可以判断基本类型,又可以判断引用类型</li><li>如果判断引用类型,判断地址是否相等</li></ol><h6 id="7-equals方法"><a href="#7-equals方法" class="headerlink" title="7. equals方法"></a>7. equals方法</h6><p>只能判断引用类型，默认判断地址是否相等，子类中往往重写该方法，用来判断内容是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">System.out.println(p1.equals(p2));<span class="comment">//false，该类没有重写equals方法，默认调用Object类的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类型判断</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span>(Person) obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age &amp;&amp; <span class="built_in">this</span>.gender == p.gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加该方法重写后，原输出为true</span></span><br></pre></td></tr></table></figure><h6 id="8-hashCode方法"><a href="#8-hashCode方法" class="headerlink" title="8. hashCode方法"></a>8. hashCode方法</h6><p>地址不同值不同,本质是建立与地址的映射</p><h6 id="9-toString方法"><a href="#9-toString方法" class="headerlink" title="9. toString方法"></a>9. toString方法</h6><ul><li>默认返回: 全类名+@+哈希值的十六进制,子类往往重写该方法,用于返回对象的属性信息   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>重写后打印对象或拼接对象时,都会默认调用该对象的toString形式</li><li>当直接输出对象时,也会默认调用该方法</li><li>alt + insert可以重写</li></ul><h5 id="10-finalize方法"><a href="#10-finalize方法" class="headerlink" title="10. finalize方法"></a>10. finalize方法</h5><ul><li>当对象被回收时,系统默认调用该对象的finalize方法.子类可以重写该方法,做一些释放资源的操作</li><li>什么时候被回收:当某个对象没有被引用时,则jvm认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁该对象,在销毁对象前,会先调用finalize方法</li><li>垃圾回收机制的调用,是由系统来决定的(有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制</li></ul><h4 id="三-java高级"><a href="#三-java高级" class="headerlink" title="三. java高级"></a>三. java高级</h4><h5 id="1-类变量和类方法"><a href="#1-类变量和类方法" class="headerlink" title="1. 类变量和类方法"></a>1. 类变量和类方法</h5><h6 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h6><ul><li>类变量即静态变量,是该类的所有对象共享的变量</li><li>定义语法: 访问修饰符 static 数据类型 变量名;</li><li>可直接通过类名.变量名直接访问(伴随着类的加载而创建,所以即使没有创建对象实例也可以访问)</li></ul><p><em>一些细节</em></p><ul><li>类变量&#x2F;静态变量,实例变量&#x2F;普通变量&#x2F;非静态变量</li><li>类变量的生命周期是随类的加载开始,随着类的消亡而销毁</li></ul><h6 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h6><ul><li>类方法也叫静态方法</li><li>形式: 访问修饰符 static 数据返回类型 方法名(){ }</li><li>类方法调用: 类名.类方法名</li></ul><p>  <em>一些细节</em></p><ul><li>类方法不允许使用和对象有关的关键字,比如this和super.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        static_.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.a);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类方法只能访问静态变量或静态方法  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">      hi();<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>普通成员方法既可访问普通变量(方法),也可以访问静态变量(方法)</li></ul><h5 id="2-main方法的语法说明"><a href="#2-main方法的语法说明" class="headerlink" title="2. main方法的语法说明"></a>2. main方法的语法说明</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure><ul><li>main方法是虚拟机调用</li><li>java虚拟机需要调用类的main()方法,所以该方法的访问权限必须时public</li><li>java虚拟机在执行main()方法时不必创建对象,所以该方法必须是static</li><li>该方法接收String类型的数组参数,该数组中保存执行Java命令时传递给所运行的类的参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java 执行的参数 参数<span class="number">1</span> 参数<span class="number">2</span> 参数<span class="number">3</span></span><br></pre></td></tr></table></figure><p>由此我们可以得出以下结论:</p><ul><li>在main()方法中,我们可以直接调用main方法所在类的静态方法或静态属性</li><li>&#x3D;&#x3D;如果要访问该类中的静态成员,必须先创建该类的一个实例对象后,才能通过这个对象去访问类中的非静态成员&#x3D;&#x3D;</li></ul><h5 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h5><p>基本介绍:又称为初始化块,属于类中的成员(类中的一部分),类似于方法,将逻辑语句封装在方法体中,通过{}包围起来.<br>但又和方法不同,没有<strong>方法名</strong>,没有<strong>返回</strong>,没有<strong>参数</strong>,只有方法体,而且不用通过对象或类显式调用,而是加载类时,或创建对象时隐式调用</p><ul><li>基本语法: [修饰符]{代码};</li><li>注意:<ul><li>修饰符可选,要写的话,也只能写static</li><li>代码块分为两类,使用static修饰的叫静态代码块,没有static修饰的,叫普通代码块</li><li>;可以写上,也可以忽略</li></ul></li><li>对于代码块理解:<ul><li>相当于另外一种形式的构造器(对构造器的补充机制),可以做初始化的操作</li><li>如果多个构造器都有重复的语句,可以抽取到初始化块中,提高代码块的重用性</li></ul></li><li>代码块的调用优先于构造器 </li><li><strong>关于代码块的细节</strong><ul><li>static代码块随着类的加载而被执行，并且只会执行一次。类加载的三种情况：<ul><li>创建对象实例(new)</li><li>创建子类对象实例,父类也会被加载</li><li>使用类的静态成员(静态方法和变量)</li><li>使用子类的静态成员(静态方法和变量),父类也会被加载</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Cat.getA());<span class="comment">//调用子类的静态方法时，父类的代码块也会被执行</span></span><br><span class="line">         System.out.println(Cat.getA());<span class="comment">//再次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父类的代码块被执行</span></span><br><span class="line">    <span class="comment">// 子类的代码块被执行</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通代码块每创建一次(new),都会被调用(可以理解为构造器的拓展)</li><li>创建一个对象时，在一个类的调用顺序：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(静态代码块和静态属性初始化)--&gt;b(普通代码块和普通属性初始化)==&gt;c(调用构造器)</span><br></pre></td></tr></table></figure>当属于同级时,看代码顺序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被调用&quot;</span>); <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块被调用&quot;</span>); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> setB(); <span class="comment">//4</span></span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通属性&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> setA(); <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被调用&quot;</span>); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态属性&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序:</span></span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="comment">// 静态代码块被调用</span></span><br><span class="line"><span class="comment">// 普通代码块被调用</span></span><br><span class="line"><span class="comment">// 普通属性</span></span><br><span class="line"><span class="comment">// 构造器被调用</span></span><br></pre></td></tr></table></figure></li></ul><p>当有子类对象时,最终顺序如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(父类的静态代码块和静态属性)==&gt;b(子类的静态代码块和静态属性)==&gt;c(父类的普通代码块和普通属性)==&gt;d(父类的构造器)==&gt;e(子类的普通代码块和普通属性)==&gt;f(子类的构造器)</span><br></pre></td></tr></table></figure><ul><li>静态代码块只能调用静态成员(方法和属性),普通代码块都可以.</li></ul><p>&#x3D;&#x3D;关于类加载的总结&#x3D;&#x3D;<br>当我们new一个实例对象后,本质上顺序为:(以下为个人理解,正确性未知)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(从父类到该子类先加载所有的静态)==&gt;b(执行构造器)</span><br></pre></td></tr></table></figure><p>而构造器中隐藏了代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">//1</span></span><br><span class="line">执行该类所有普通代码块和属性方法 <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4. 单例设计模式"></a>4. 单例设计模式</h5><p>采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法</p><p>步骤:</p><ol><li>构造器私有化</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法</li></ol><h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;<span class="comment">//私有构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">myGirl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;xxx&quot;</span>,<span class="number">18</span>); <span class="comment">//内部自行创建实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123; <span class="comment">//提供返回方法</span></span><br><span class="line">        <span class="keyword">return</span> myGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend myGirl ;<span class="comment">//只创建不new</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加载</span></span><br><span class="line">        <span class="keyword">if</span>(myGirl == <span class="literal">null</span>)&#123;</span><br><span class="line">            myGirl = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;xxx&quot;</span>,<span class="number">18</span>); <span class="comment">//用if来判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对上述两种方法类加载时,静态方法和变量都会被加载,但一种方法类似于给实例对象赋值,调用了构造器,而第二种虽然也加载了构造器,但是没调用</p><h5 id="5-final关键字"><a href="#5-final关键字" class="headerlink" title="5. final关键字"></a>5. final关键字</h5><p>  可以修饰 类、属性、方法、局部变量<br>  一般用XX_XX修饰，也就是常量<br>  应用场景</p><ul><li>不希望类被继承时</li><li>不希望父类的某个方法被子类覆盖时</li><li>不希望类的某个属性值被修改时</li><li>不希望某个局部变量被修改时</li></ul><p>注意细节</p><p>final修饰时必须赋初值</p><ul><li><p>以下三种合理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FINAL_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//定义时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FINAL_</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        B = b;<span class="comment">//构造器初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        C = <span class="number">3</span>; <span class="comment">//代码块初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果修饰静态，则初始化位置只能是定义时或静态代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FINAL_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FINAL_</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        B = b;<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        C = <span class="number">3</span>;<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为定义的静态变量时，必须要求加载时完成初始化，后续不能再进行修改</p></li><li><p>final类不能被继承，但是可以实例化对象(废话…)</p></li><li><p>如果不是final类,但是有final方法,则该方法可以被继承(也是废话…)</p></li><li><p>类已经final了,里面方法没必要再添加final(已经不能继承了…)</p></li><li><p>final不能修饰构造器(也是废话…)</p></li><li><p>final和static往往搭配使用,效率更高,底层编译器做了优化处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(XXX.A);  <span class="comment">//只输出1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包装类(Integer,Double,Float,Boolean,String)等都是final</p></li></ul><h5 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. 抽象类</h5><p>   当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类细节</p><ul><li>抽象类不能被实例化</li><li>抽象类可以没有抽象方法</li><li>abstract只能修饰类和方法</li><li>一个类继承抽象类时,则必须实现其所有方法,除非自己也声明为abstract类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YYY</span> <span class="keyword">extends</span> <span class="title class_">XXX</span>&#123; <span class="comment">//实现父类XXX f()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ZZZ</span> <span class="keyword">extends</span> <span class="title class_">XXX</span>&#123;<span class="comment">//也声明为抽象方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象方法不能使用private,final和static来修饰,因为这些关键字都是和重写相违背的</li></ul></li></ul><h5 id="7-抽象类的最佳实践-模板设计模式"><a href="#7-抽象类的最佳实践-模板设计模式" class="headerlink" title="7. 抽象类的最佳实践(模板设计模式)"></a>7. 抽象类的最佳实践(模板设计模式)</h5><p>  本质原理是动态绑定机制,仔细品味以下妙处</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job();<span class="comment">//抽象方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            res +=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() ;</span><br><span class="line">        System.out.println(a.cal());</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">B</span>() ;</span><br><span class="line">        System.out.println(b.cal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-接口"><a href="#8-接口" class="headerlink" title="8. 接口"></a>8. 接口</h5><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 接口名 &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法(抽象方法,默认实现方法,静态方法)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">//自己属性</span></span><br><span class="line">    <span class="comment">//自己方法</span></span><br><span class="line">    <span class="comment">//必须实现的接口的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk7.0前,接口里的所有方法都没有方法体.在jdk8后接口中可以有静态方法,默认方法,也就是接口中可以有方法的具体实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//允许</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>); <span class="comment">//添加default</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">okk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;okk&quot;</span>); <span class="comment">//或者添加static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口使用细节</p><ul><li>抽象类实现接口，可以不用实现接口的方法</li><li>一个类可以同时实现多个接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;&#125; <span class="comment">//使用implements</span></span><br></pre></td></tr></table></figure></li><li>接口中的属性是public,static,final修饰符<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>&lt;==&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>接口不能继承其他的类,但是可以继承多个别的接口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IC</span> <span class="keyword">extends</span> <span class="title class_">IB</span>,IC <span class="comment">//extends</span></span><br></pre></td></tr></table></figure></li><li>接口的修饰符只能是<strong>默认</strong>和<strong>public</strong></li><li>接口的多态传递现象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IA</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">        test.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> <span class="keyword">extends</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">IB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了IA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IB继承IA,X实现了IB，</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="9-内部类"><a href="#9-内部类" class="headerlink" title="9. 内部类"></a>9. 内部类</h5><h6 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h6><ul><li>定义在外部类的局部位置,通常在方法</li><li>可以访问外部类的所有成员，包括私有</li><li>不能添加访问修饰符，可以用final修饰(因为其实是局部变量)</li><li>作用域：仅仅在定义它的方法或代码块中,所以外部其他类不能访问该类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nei</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//可以访问外部类的所有成员，包括私有的</span></span><br><span class="line">                System.out.println(n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">//代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Inner01</span> &#123;</span><br><span class="line">                <span class="type">int</span> n2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果与外部类重名，遵循就近原则，调用外部成员可用 外部类.this.成员 的形式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nei</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//可以访问外部类的所有成员，包括私有的</span></span><br><span class="line">                System.out.println(Nei.<span class="built_in">this</span>.n1);<span class="comment">//调用外部类的n1的格式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//输出100</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="匿名内部类-重要"><a href="#匿名内部类-重要" class="headerlink" title="匿名内部类(重要!!!)"></a>匿名内部类(重要!!!)</h6><p>基本语法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是A的匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是B的匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">//</span></span><br><span class="line">        a.test();</span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>性质与内部类性质一致</li><li>应用,例如:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Anom</span> <span class="variable">anom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Anom</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        anom.f(b); <span class="comment">//传统方法</span></span><br><span class="line">        anom.f(<span class="keyword">new</span> <span class="title class_">B</span>() &#123; <span class="comment">//采用匿名内部类的写法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我实现了接口B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我实现了接口B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h6><ul><li>其性质也与局部内部类相似</li><li>可以添加任意访问修饰符,因为其本质为成员(private,public,默认,protected)</li><li>外部其他类可以访问到成员内部类.访问方式:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//第一种</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> a.getB(); <span class="comment">//第二种</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//或者直接new,如果不需要a实例对象的话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(A.<span class="built_in">this</span>.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h6><ul><li><p>可以访问外部类的所有静态成员</p></li><li><p>可以加访问修饰符(private,默认,protected,public)</p></li><li><p>作用域同其他成员</p></li><li><p>外部类访问静态内部类,先创建对象再访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//先创建对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>外部其他类访问内部静态类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>.B();<span class="comment">//第一种方法,其实就是不用再创建A的实例对象</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().getB(); <span class="comment">//第二种方法,需要用到A的普通方法,所以这里需要创建A的实例对象</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b3</span> <span class="operator">=</span> A.getBB(); <span class="comment">//第三种方法,也不用创建A</span></span><br><span class="line">        b3.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(A.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getBB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可通过类名.成员名去访问外部成员,如上例的f()函数</p></li></ul><h3 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h3><h5 id="1-枚举类"><a href="#1-枚举类" class="headerlink" title="1. 枚举类"></a>1. 枚举类</h5><ul><li><p>枚举是一组常量的集合,是一种特殊的类,里面只包含有限的特定的对象</p></li><li><p>实现方式</p><ol><li>自定义<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 将构造器私有化,防止直接被new</span></span><br><span class="line"><span class="comment">//2. 去掉setXXX方法,防止属性被修改</span></span><br><span class="line"><span class="comment">//3. 再Season内部,直接创建固定的对象</span></span><br><span class="line"><span class="comment">//4. 优化,再加入final修饰符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>enum关键字</li></ol><ul><li>使用关键字enum代替class</li><li>将定义常量对象写在最前面</li><li>格式:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>),ME;<span class="comment">//多个常量对象之间用逗号隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当我们使用enum关键字开发一个枚举类时,默认会继承Enum类,而且是一个<strong>final</strong>类</p></li><li><p>但enum实现的枚举类仍然是一个类，所以还是可以实现接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用无参构造器创建枚举对象时,参数列表和<strong>小括号</strong>都可以省略</p></li><li><p>常用enum方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN.name()); <span class="comment">//1. AUTUMN(返回该对象的名称)</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Season.SUMMER.ordinal()); <span class="comment">//2. 1 (从0开始)</span></span><br><span class="line"></span><br><span class="line">        Season[] values = Season.values(); <span class="comment">//3. 得到所有枚举对象的一个数组</span></span><br><span class="line">        <span class="keyword">for</span> (Season season : values) &#123;</span><br><span class="line">            System.out.println(season.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Season.valueOf(<span class="string">&quot;AUTUMN&quot;</span>).name()); <span class="comment">//4. valueOf，将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</span></span><br><span class="line">        System.out.println(Season.SPRING.compareTo(Season.SUMMER)); <span class="comment">//5. 将两对象的ordinal进行比较返回第一个的编号减去第二个的编号</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>),ME;<span class="comment">//多个常量对象之间用逗号隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-注解"><a href="#2-注解" class="headerlink" title="2. 注解"></a>2. 注解</h5><ul><li>Override<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;<span class="comment">//看到类似的代码表示注解</span></span><br><span class="line"><span class="comment">//@target是Override的注解,称为元注解</span></span><br><span class="line"><span class="comment">//@Override只能修饰方法</span></span><br></pre></td></tr></table></figure></li><li>Deprecated<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span><span class="comment">//不推荐使用,但是仍然可以使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="comment">//可以修饰方法\类\字段\包\参数等等</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the version in which the annotated element became deprecated.</span></span><br><span class="line"><span class="comment">     * The version string is in the same format and namespace as the value of</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> <span class="doctag">@since</span>&#125; javadoc tag. The default value is the empty</span></span><br><span class="line"><span class="comment">     * string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the version string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">since</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether the annotated element is subject to removal in a</span></span><br><span class="line"><span class="comment">     * future version. The default value is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether the element is subject to removal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SuppressWarings<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;,&quot;&quot;&#125;)</span><span class="comment">//抑制的警告类型</span></span><br><span class="line"><span class="comment">//放在具体的位置来抑制警告信息</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;<span class="doctag">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于元注解</li></ul><ol><li>Retention</li><li>Target</li><li>Documented</li><li>Inherited</li></ol><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="/Throwable.png"><br>五大运行时异常</p><ul><li><p>NullPointerException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(name.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ArithmeticException<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArraylndexOutOfBoundsException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ClassCastException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">       <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> (B) b; <span class="comment">//向下转型</span></span><br><span class="line">       <span class="type">C</span> <span class="variable">b2</span> <span class="operator">=</span>(C) b; <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>NumberFormatException</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;asff&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>try catch异常处理</p><ol><li>可以有多个catch语句，捕获不同的异常(进行不同的业务处理),要求子类异常在前，父类一场在后，如果发生异常，只会匹配一个catch</li><li>可以进行try-finally配合使用，不管发不发生异常，程序都会崩溃。不管程序异不异常，都必须执行finally的业务逻辑。<br>下面注意一个很怪的练习<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[<span class="number">3</span>].equals(<span class="string">&quot;zxcs&quot;</span>)) &#123; <span class="comment">//首先是数组索引越界异常,才是空指针异常</span></span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还要被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出: 我还要被执行 2</span></span><br><span class="line"><span class="comment">//无论如何，程序一定会把所有都执行完毕才会返回，交换顺序照样得到一样的结果</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[<span class="number">3</span>].equals(<span class="string">&quot;zxcs&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 3,最后才会返回</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><p>注意事项</p><ul><li>对于编译异常，程序必须处理</li><li>对于运行时异常，程序如果没有处理，默认是throws的方式处理</li><li>子类重写父类的方法时，对抛出异常的规定：所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//false ,不允许出现类似的情况</span></span><br></pre></td></tr></table></figure></li><li>如果有trycatch，就不必throws</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        f2(); <span class="comment">//false</span></span><br><span class="line">        f3(); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义异常</p><ul><li>一般继承RuntimeException，比较方便<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;异常&quot;</span>); <span class="comment">//使用的是throw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="throw和throws区别"><a href="#throw和throws区别" class="headerlink" title="throw和throws区别"></a>throw和throws区别</h6><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>  下面该练习值得好好推敲</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            A.f1();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        A.f2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我进入f1方法&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主动抛出的异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1方法进入finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我进入了方法B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2方法进入finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h5 id="包装类-Wrapper"><a href="#包装类-Wrapper" class="headerlink" title="包装类(Wrapper)"></a>包装类(Wrapper)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph BT</span><br><span class="line">b(Byte)==&gt;n(Number)</span><br><span class="line">i(integer)==&gt;n</span><br><span class="line">l(Long)==&gt;n</span><br><span class="line">f(Float)==&gt;n</span><br><span class="line">d(Double)==&gt;n</span><br><span class="line">s(Short)==&gt;n</span><br><span class="line">b(Byte)==&gt;c(Comparable)</span><br><span class="line">i(integer)==&gt;c</span><br><span class="line">l(Long)==&gt;c</span><br><span class="line">f(Float)==&gt;c</span><br><span class="line">d(Double)==&gt;c</span><br><span class="line">s(Short)==&gt;c</span><br><span class="line">n==&gt;o(Object)</span><br><span class="line">n==&gt;Serializable(Serializable)</span><br><span class="line">Boolen(Boolen)==&gt;o</span><br><span class="line">Boolen==&gt;Serializable</span><br><span class="line">Boolen==&gt;c</span><br><span class="line">Character(Character)==&gt;o</span><br><span class="line">Character==&gt;Serializable</span><br><span class="line">Character==&gt;c</span><br></pre></td></tr></table></figure><p>包装类的基本数据类型转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1); <span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1); <span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> integer.intValue(); <span class="comment">//手动拆箱,注意拆箱用的是实例对象的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱和拆箱,jdk5之后</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> integer;</span><br></pre></td></tr></table></figure><p>一个细节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//obj = 1.0;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字转字符串类型的方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> integer.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> Integer.toString(<span class="number">123</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(integer);</span><br><span class="line"><span class="type">String</span> <span class="variable">string4</span> <span class="operator">=</span> integer + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符转数字的方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.valueOf(string1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(string1);    </span><br><span class="line"><span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(integer1 == integer2);<span class="comment">//true</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(integer1 == integer2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(integer1 == integer3);<span class="comment">//只要出现基本数据类型,比较的是值的大小</span></span><br></pre></td></tr></table></figure><h5 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h5><p><img src="/String.png"></p><p>保存字符串，而字符串的字符通常采用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p><ul><li>String是final类,不能被其他类继承.</li><li>String的属性 private final char value[];用于存放字符串内容</li><li>一定要注意:value是一个final类型,不可以修改(<strong>指的是地址不能被修改</strong>)</li><li>两种创建String方式的区别<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">String b= <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">System.out.println(a == b) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//常量池创建,如果已有,则直接指向该常量池地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span>;</span><br><span class="line">System.out.println(str == <span class="string">&quot;ya&quot;</span>);<span class="comment">//true,&quot;ya&quot;直接是常量池的地址</span></span><br></pre></td></tr></table></figure></li><li>String.intern()方法,返回常量池相同的字符串的地址</li><li>String特性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span> + <span class="string">&quot;ng&quot;</span>;<span class="comment">//编译器一共创建了一个对象,因为其会做底层优化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ng&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> str1 + str2;<span class="comment">//创建了四个地址,需要深入了解底层实现机制</span></span><br><span class="line">System.out.println(end == str); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结:</span></span><br><span class="line"><span class="comment">//1. StringBuilder sb = new StringBuilder;</span></span><br><span class="line"><span class="comment">//2. sb.append(str1);</span></span><br><span class="line"><span class="comment">//3. sb.append(str2);</span></span><br><span class="line"><span class="comment">//4. String end = sb.toString();</span></span><br></pre></td></tr></table></figure></li><li>常量相加,看的是池;变量相加,是在堆中</li></ul><p>一道测试题，主要考察之前的方法传参机制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;yang&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str );</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//yang</span></span><br><span class="line">    <span class="comment">//hbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String类的常见方法(没有改变原对象,需要被接受返回值)</p><ul><li>equals</li><li>equalsIgnoreCase(忽略大小写)</li><li>length</li><li>indexOf(字符在字符串中第一次出现的位置,且从0开始)(还可以是字符串)</li><li>lastIndexOf(字符在字符串中最后一次出现的位置,也从0开始)</li><li>substring(index1,index2)(从index1开始到index2)</li><li>toUpperCase(转大写)</li><li>toLowerCase(转小写)</li><li>concat(str.concat(“”))(拼接)</li><li>replace(substr1,target)(将substr1替换成target)</li><li>split()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦&quot;</span>;</span><br><span class="line">       String [] s = str.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;<span class="comment">//结果返回一个数组</span></span><br><span class="line">        <span class="comment">//如果有特殊字符，需要转移字符，如要替换/应该是//</span></span><br></pre></td></tr></table></figure></li><li>toCharArray(转换为字符数组)</li><li>compareTo(比较两个字符串的大小)(比较规则:若长度不等,返回长度的差值;否则从0开始比较,直到遇到第一组不相等的字符,返回其码值大小差)</li><li>format(“”,变量名)(c语言的printf格式)</li></ul><p>StringBuffer类<br><img src="/StringBuffer.png"></p><ul><li><p>在父类中，AbstractStringBuilder有属性 char[] value，不是final(因此存放在堆中)</p></li><li><p>StringBuffer构造器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">//capacity = 16</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">100</span>); <span class="comment">//capacity = 100</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//capacity = 16 + 5</span></span><br></pre></td></tr></table></figure><p>StringBuffer 的转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">//String转成StringBuffer</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(string);<span class="comment">//返回的才是StringBuffer对象</span></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer1.append(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//StringBuffer转成String</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer1.toString();</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>StringBuffer常见方法(是直接对实例对象进行的修改)</p><ol><li>增:append()</li><li>删:delete(index1,index2)(删除index1到index2-1位置的字符)</li><li>改:replace(index1,index2,target)(替换index1到index2-1的字符为target)(与String类有差异,注意辨别)</li><li>查:indexOf()</li><li>insert(index.target)(在索引为index位置插入target,原来索引自动后移)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">stringBuffer.insert(<span class="number">1</span>,<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer);</span><br><span class="line"><span class="comment">//ainsertbc</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>length()</p></li></ul><p>一些练习题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer.append(string);</span><br><span class="line">System.out.println(stringBuffer);</span><br><span class="line"><span class="comment">////输出null,需要看底层原码,底层调用AbstractStringBuilder的appendNull,赋予了长度为4的字符串null</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(string);</span><br><span class="line">System.out.println(stringBuffer1);</span><br><span class="line"><span class="comment">//抛出空指针异常,也是需要看底层原码</span></span><br></pre></td></tr></table></figure><h5 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h5><p>介绍:一个可变的字符序列,此类提供一个与StringBuffer兼容的API,但不保证同步(StringBuilder 不是线程安全).该类被设计用作StringBuffer的一个简易替换,用在字符串缓冲区被单个线程使用的时候.如果可能,建议优先采用该类.</p><ul><li>主要使用append和insert方法,可重载这些方法,已接受任意类型的数据<br><img src="/StringBuilder.png"></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2024/03/20/Liinux/"/>
      <url>/2024/03/20/Liinux/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h3><h4 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h4><ul><li>为树型结构</li><li>只有一个根目录</li><li>层级关系用 &#x2F; 表示</li><li>出现在开头的根目录用 &#x2F; 表示</li></ul><h4 id="Linux命令入门"><a href="#Linux命令入门" class="headerlink" title="Linux命令入门"></a>Linux命令入门</h4><h5 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h5><ul><li>通用格式 command [- options] [parameter]</li></ul><h5 id="ls命令入门"><a href="#ls命令入门" class="headerlink" title="ls命令入门"></a>ls命令入门</h5><ul><li>ls [-a -l -h] [Linux 路径]</li></ul><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul><li>-a 即all，列出全部文件（包含隐藏的文件&#x2F;文件夹）</li><li>-l 以列表（竖向排列）的形式展示内容，并展示更多信息</li><li>-h 需要和-l配合使用，显示文件大小</li></ul><h6 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h6><ul><li>路径显示</li></ul><h5 id="cd-pwd命令"><a href="#cd-pwd命令" class="headerlink" title="cd-pwd命令"></a>cd-pwd命令</h5><ul><li>cd [Linux 路径]</li><li>pwd 输出当前所在根目录</li></ul><h5 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h5><ul><li>绝对路径：以根目录为起点，以&#x2F;开头</li><li>相对路径：以当前目录为起点</li><li>特殊路径符：<ul><li>. 表示当前目录，比如cd.&#x2F;Desktop 与cd Desktop一致</li><li>.. 表示上一级目录</li><li>~ 表示HOME目录，cd~&#x2F;Desktop 表示切换到HOME的Desktop目录</li></ul></li></ul><h5 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h5><ul><li>mkdir [-p] Linux 路径  （创建新文件夹）</li><li>-p 表示自动创建不存在的目录</li></ul><h5 id="文件命操作命令"><a href="#文件命操作命令" class="headerlink" title="文件命操作命令"></a>文件命操作命令</h5><ul><li><p>touch Linux路径 （创建新文件）</p></li><li><p>cat Linux路径 （查看文件内容）</p></li><li><p>more Linux路径 （查看文件内容，空格翻页，B键上一页，q键退出）</p></li><li><p>cp [-r] 参数1 参数2</p><ul><li>-r 表示递归（复制文件夹时使用）</li><li>参数1，源文件</li><li>参数2，目标文件</li></ul></li><li><p>mv 参数1 参数2</p><ul><li>参数1，源文件</li><li>参数2，目标文件 （文件不存在，则有改名效果）</li></ul></li><li><p>rmdir 文件夹 删除空文件夹</p></li><li><p>rm [- -f] 参数1 参数2 … 参数n</p><ul><li>-r 用于删除文件夹</li><li>-f 强制删除</li><li>支持通配符<ul><li>test* 表示匹配任何以test开头的内容</li><li>*test 表示匹配任何以test结尾的内容、</li><li>*test*表示匹配任何包含test的内容</li></ul></li></ul></li></ul><h5 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h5><ul><li>which 要查找的命令</li></ul><h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><ul><li>find 起始路径 -name “被查找的文件名”<ul><li>-name 按文件名搜索</li><li>-size 按文件大小搜索<ul><li>+ - 表示大于和小于</li><li>n 代表大小数字</li><li>k M G 注意大小写，表示大小</li><li>-type 按文件类型搜索</li><li>-maxdepth 指定搜索深度</li><li>-exec ls -ld {} ; exec 将find的结果集执行某一指定命令</li><li>-xargs ls -d 将find搜索的结果集执行某一指定命令。当结果集数量过大时，可以分片映射</li><li>-ok 交互式方式</li></ul></li></ul></li></ul><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><ul><li>grep [-n] 关键字 文件路径<ul><li>-n 表示在结果中显示匹配的行的行号</li><li>参数 文件路径，可作为管道符的输入</li></ul></li></ul><h5 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h5><ul><li>wc [-c -m -l -w] 文件路径<ul><li>不带选项默认统计：行数、单词数、字节数、字符数等</li><li>-c 字节数 </li><li>-m 字符数</li><li>-l 行数</li><li>-w 单词数</li><li>参数 被统计的文件路径，可作为管道符的输入</li></ul></li></ul><h5 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h5><ul><li>x|y  将管道左边命令的结果，作为右边命令的输入</li></ul><h5 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h5><ul><li>echo 输出的内容</li></ul><h5 id="命令"><a href="#命令" class="headerlink" title="&#96;命令"></a>&#96;命令</h5><ul><li>被&#96;包围的内容，会被作为命令执行，而非普通字符</li></ul><h5 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h5><ul><li><code>&gt;</code>  将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li><li><code>&gt;&gt;</code> 将左侧命令的结果，追加写入到符号右侧的指定文件中</li></ul><h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h5><ul><li>tail [-f -num] Linux路径<ul><li>-f 持续追踪，Ctrl + c可以退出</li><li>-num 查看尾部多少行，默认为10行</li></ul></li></ul><h5 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi\vim编辑器"></a>vi\vim编辑器</h5><ul><li>vim 文件路径</li><li>vi 文件路径</li><li>运行模式<ul><li>命令模式</li><li>输入模式</li><li>底线命令模式</li><li><a href="https://www.runoob.com/linux/linux-vim.html">常用命令</a></li></ul></li></ul><h3 id="Linux用户和权限"><a href="#Linux用户和权限" class="headerlink" title="Linux用户和权限"></a>Linux用户和权限</h3><h4 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h4><ul><li><p>Linux系统的超级管理员用户是：root用户</p></li><li><p>su [-] [用户名]</p><ul><li><ul><li>表示切换后加载环境变量，建议带上</li></ul></li><li>用户可以省略，省略默认切换到root</li></ul></li><li><p>sudo 其他命令</p><ul><li>需要以root用户执行visudo命令，增加配置</li><li>增加配置项如下 baiy ALL&#x3D;(ALL)   NOPASSWD:ALL</li><li>并以wq保存</li></ul></li></ul><h4 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h4><ul><li>groupadd 用户组名 </li><li>groupdel 用户组名</li><li>useradd  [-g -d] 用户名<ul><li>-g 指定用户的组  若不指定则会创建同名组并自动加入</li><li>-d 指定用户HOME路径，不指定，HOME目录默认在: &#x2F;home&#x2F;用户名</li></ul></li><li>userdel [-r] 用户名<ul><li>-r 删除用户的HOME目录，不使用-r，删除用户时，HOME仍保留</li></ul></li><li>usermod<ul><li>-aG 用户组 用户名，将指定用户加入指定用户组</li></ul></li><li>id [用户名]<ul><li>不加则默认查看root用户</li></ul></li><li>getent passwd</li><li>getent group</li></ul><h4 id="查看权限控制"><a href="#查看权限控制" class="headerlink" title="查看权限控制"></a>查看权限控制</h4><p>  <img src="/rwx.png"></p><ul><li>rwx 分别代表 读、写、执行权限</li><li>前10个字符分别代表文件类型、所属用户权限、所属用户组权限、其它用户权限</li></ul><h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><ul><li>chmod [-R] 权限 文件或文件夹<ul><li>-R 将文件夹内的全部内容应用同样规则 （注意要为大写）</li></ul></li></ul><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><ul><li>chown [-R] [用户]:[用户组] 文件或文件夹<ul><li>-R 同文件夹内全部应用此规则</li></ul></li></ul><h3 id="Linux实用操作"><a href="#Linux实用操作" class="headerlink" title="Linux实用操作"></a>Linux实用操作</h3><h4 id="各类小技巧"><a href="#各类小技巧" class="headerlink" title="各类小技巧"></a>各类小技巧</h4><ul><li>ctrl+c 强制停止或重新输入</li><li>ctrl+d 退出账户的登录或某些特定程序的专属页面</li><li>history 查看历史命令</li><li>!命令前缀，自动执行上一次匹配前缀的命令</li><li>ctrl+r 输入内容匹配历史命令</li><li>ctrl + &lt;- -&gt; a e 光标跳跃</li><li>ctrl+l 清屏</li></ul><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><ul><li>CentOs系统 yum [-y] [install | remove | search] 软件名称  (.rpm)</li><li><ul><li>Ubuntu系统 apt [-y] [install | remove | search] 软件名称  (.deb)</li><li>离线下载：dpkg -i 安装包名</li></ul></li></ul><h4 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h4><ul><li>systemctl start | stop | status | enable | disable 服务名<ul><li>可控制软件（服务）的启动、关闭、开机和自启动</li></ul></li></ul><h4 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h4><ul><li>ln -s 参数1 参数2<ul><li>不加-r，硬链接：操作系统给每一个文件赋予唯一的inode，当有相同的inode文件存在时，彼此同步</li><li>-s 创建软链接</li><li>参数1 源文件（夹）</li><li>参数2 目标文件（夹）</li><li>注意：推荐将源文件用绝对路径表示，否则在将软链接文件转移到别处后将失效</li></ul></li></ul><h4 id="日期和时区"><a href="#日期和时区" class="headerlink" title="日期和时区"></a>日期和时区</h4><ul><li><p>date [-d][+格式化字符串]</p><ul><li>%Y 年</li><li>%y 年份后两位数字</li><li>%M 月份</li><li>%d 日</li><li>%H 小时</li><li>%M 分钟</li><li>%S 秒</li><li>%s 自1970-01-01 00:00:00 到现在的秒数</li></ul></li><li><p>修改时区</p><ul><li>rm -f &#x2F;etc&#x2F;localtime</li><li>sudo ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Aisa&#x2F;Shanghai &#x2F;etc&#x2F;localtime</li></ul></li><li><p>ntp</p><ul><li>可以自动联网同步时间</li><li>手动方法 ntpdate -u ntp.aliyun.com</li></ul></li></ul><h4 id="配置Linux固定IP"><a href="#配置Linux固定IP" class="headerlink" title="配置Linux固定IP"></a>配置Linux固定IP</h4><ol><li>在VMware Workstation（或Fusion）中配置IP地址网关和网段（IP地址的范围）</li><li>在Linux系统中手动修改配置文件，固定IP</li></ol><h4 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h4><h5 id="网络请求和下载"><a href="#网络请求和下载" class="headerlink" title="网络请求和下载"></a>网络请求和下载</h5><ul><li>ping [-c num] ip或主机名<ul><li>-c，测试的次数</li></ul></li><li>wget [-b] url<ul><li>-b 后台下载</li></ul></li><li>curl [-O] url<ul><li>-O 用于下载使用</li></ul></li></ul><h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><ul><li>nmap IP地址，查看指定IP的对外暴露端口</li><li>netstat -anp|grep 端口号 查看本机指定端口号的占用情况</li><li>端口划分<ul><li>公认端口：1~1023，用于系统内置或常用知名软件绑定使用</li><li>注册端口：1024~49151，用于松散绑定使用（用户自定义）</li><li>动态端口：49152~65535，用于临时使用（多用于出口）</li></ul></li></ul><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><ul><li><p>ps -ef | grep 关键字 查看关键字相关进程信息</p></li><li><p>kill [-9] 进程号</p><ul><li>[-9] 强制关闭</li></ul></li><li><p><img src="/ps.png"></p><ul><li>UID：进程所属用户ID</li><li>PID：进程的进程号ID</li><li>PPID：进程的父ID（启动此进程的其它进程）</li><li>C：此进程的CPU占用率</li><li>STIME：进程的启动时间</li><li>TTY：启动此进程的终端序号，如显示？，表示非终端启动</li><li>TIME：进程占用CPU的时间</li><li>CMD：进程对应的名称或启动路径或启动命令</li></ul></li></ul><h4 id="主机状态监控"><a href="#主机状态监控" class="headerlink" title="主机状态监控"></a>主机状态监控</h4><ul><li>top 查看CPU、内存、进程的信息</li><li>df [-h]查看磁盘使用率</li><li>-h 显示内存大小</li><li>iostat 查看磁盘速率等信息</li><li>sar -n DEV 查看网络情况</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul><li>env 查看当前系统配置的环境变量信息</li><li>$ 取出环境变量信息</li><li>PATH 记录命令的搜索路径用:隔开</li><li>临时生效：export 名称&#x3D;值 </li><li>永久生效：<ul><li>针对用户： ~&#x2F;bashrc 中配置</li><li>针对全部用户：&#x2F;etc&#x2F;profile 中配置</li><li>配置完成 source 立刻生效</li></ul></li></ul><h4 id="rz-sz"><a href="#rz-sz" class="headerlink" title="rz sz"></a>rz sz</h4><ul><li>rz 进行文件上传</li><li>sz 进行文件下载</li></ul><h4 id="Linux压缩和解压"><a href="#Linux压缩和解压" class="headerlink" title="Linux压缩和解压"></a>Linux压缩和解压</h4><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><ul><li>-z gzip模式</li><li>tar[-z -x -v -c -f -C]参数</li><li>-c 创建压缩文件  -x 解压模式</li><li>-v 查看压缩、解压过程</li><li>-f 指定压缩、解压文件</li><li>-C 指定压缩路径</li></ul><h5 id="zip与unzip"><a href="#zip与unzip" class="headerlink" title="zip与unzip"></a>zip与unzip</h5><ul><li>zip [-r]压缩文件（夹）名 要压缩的文件名…<ul><li>-r 压缩文件夹时使用</li></ul></li><li>unzip [-d] 解压文件夹名<ul><li>-d 指定解压的目录 （与tar中的C作用类似）</li></ul></li></ul><h3 id="Linux-系统编程"><a href="#Linux-系统编程" class="headerlink" title="Linux 系统编程"></a>Linux 系统编程</h3><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test //如果未指定输出文件名称，默认输出为a.out。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>* </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -S test.i</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c test.s</span><br></pre></td></tr></table></figure><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure><h5 id="编译优化指令"><a href="#编译优化指令" class="headerlink" title="编译优化指令"></a>编译优化指令</h5><ul><li>有四个级别0~3,级别越高优化越好，但编译时间越长，中间代码可读性越差。0级无优化效果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -O1 test.c -o test</span><br></pre></td></tr></table></figure></li></ul><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><h5 id="I"><a href="#I" class="headerlink" title="-I"></a>-I</h5><ul><li>指定头文件目录</li></ul><h5 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h5><ul><li>只做预处理、编译、汇编。得到二进制文件</li></ul><h5 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h5><ul><li>编译时添加调试文件</li></ul><h5 id="Wall"><a href="#Wall" class="headerlink" title="-Wall"></a>-Wall</h5><ul><li>显示所有警告</li></ul><h5 id="向程序中动态定义宏"><a href="#向程序中动态定义宏" class="headerlink" title="向程序中动态定义宏"></a>向程序中动态定义宏</h5><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><h5 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h5><ol><li>将 .c 生成 .o 文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c 文件.c -o 文件.o</span><br></pre></td></tr></table></figure></li><li>使用ar工具制作静态库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar rcs lib库名.a 文件.o</span><br></pre></td></tr></table></figure></li><li>编译静态库到可执行文件中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.c lib库名.a -o a.out</span><br></pre></td></tr></table></figure></li></ol><h5 id="头文件守卫"><a href="#头文件守卫" class="headerlink" title="头文件守卫"></a>头文件守卫</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H_</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><h5 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h5><ol><li><p>将.c 文件生成 .o （生成与位置无关的代码 -fPIC）</p></li><li><p>使用gcc -shared -o lib库名.so  文件名.o</p></li><li><p>编译可执行程序时指定所使用的动态库 </p><ul><li>-l 指定库名 （去掉前缀lib）</li><li>-L 指定库路径</li></ul></li><li><p>运行可执行程序出错！！！</p><ul><li>链接器：工作于链接状态，工作时需要 -l和-L</li><li>动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置</li><li>解决方法：export LD_LIBRARY_PATH&#x3D;动态库路径 （关闭进程后失效）（建议绝对路径）</li></ul></li></ol><h4 id="gdb调试工具"><a href="#gdb调试工具" class="headerlink" title="gdb调试工具"></a>gdb调试工具</h4><ul><li>使用-g可以得到调试表</li></ul><h5 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h5><ul><li>list：列出源码</li><li>break num：设置断点</li><li>run：运行程序</li><li>next：下一条指令（会越过函数）</li><li>step：下一条指令（会进入函数）</li><li>print i：查看变量的值</li><li>continue：继续执行断点后续指令</li><li>quit：退出当前调试</li></ul><h5 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h5><ul><li>finish 结束当前函数的调用</li><li>set args:设置main函数命令行参数</li><li>info b 显示断点信息</li><li>b 20 if i &#x3D; 5 设置条件断点 </li><li>ptype 查看变量类型</li></ul><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><ul><li><p>一个规则</p><ul><li>目标：依赖条件<br>  （一个tab缩进）命令<ol><li>目标的时间必须晚于依赖条件的时间没否则更新目录</li><li>依赖条件如果不存在，则寻找新的规则去依赖</li></ol><ul><li>ALL:指定makefile的终极目标</li></ul></li></ul></li><li><p>2个函数</p><ul><li>src &#x3D; $(wildcard .&#x2F;*.c) 匹配当前工作目录下的所有.c文件，将文件名组成列表赋值给变量src</li><li>obj &#x3D; $(patsubst %.c,%.o,$(src)) 将参数3中包含参数1的部分替换为参数2<br>clean:(没有依赖)<br>-rm -rf $(obj) a.out （”-“的作用:删除不存在文件时，不报错，顺序执行结束）</li></ul></li><li><p>三个自动变量</p><ul><li>$@: 在规则的命令中，表示规则中的目标</li><li>$&lt;: 在规则的命令中，表示第一个依赖条件,如果将该变量用于模式规则中,它将条件依赖列表中的依赖依次取出,套用模式规则</li><li>$^: 在规则的命令中，表示所有依赖条件</li></ul></li><li><p>模式规则</p><ul><li>%.o : %.c<br>gcc -c $&lt; -o $@</li></ul></li><li><p>伪目标</p><p>.PHONY: clean ALL</p></li></ul><h4 id="open-read-write"><a href="#open-read-write" class="headerlink" title="open,read,write"></a>open,read,write</h4><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><p>int open(char *pathname,int flags,(mode_t mode))  #include &lt;unistd.h&gt;</p><ul><li>参数:<ul><li>pathname: 文件路径</li><li>flags: 文件打开方式 #include &lt;fcntl.h&gt;<ul><li>O_RDONLY | O_WRONLY | O_RDWR</li><li>O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK …</li><li>参数3使用前提，参数2指定了O_CREAT 如：0664<ul><li>创建文件最终权限: mode &amp; ~umask</li></ul></li></ul></li></ul></li><li>返回值<ul><li><p>成功: 打开文件所得到对应的文件描述符（整数）</p></li><li><p>失败: -1，设置errno</p></li></ul></li></ul><h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>int close(int fd)</p><h5 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h5><p>与errno有关</p><ul><li>strerror(errno)</li></ul><h5 id="read"><a href="#read" class="headerlink" title="read"></a>read</h5><p>ssize_t read(int fd,void *buf,size_t count);</p><ul><li>参数<ul><li>fd:文件描述符</li><li>buf: 存数据的缓冲区</li><li>count: 缓冲区的大小</li></ul></li><li>返回值<ul><li>0: 读到文件末尾</li><li>成功: 读到的字节数</li><li>失败: -1,设置errno</li></ul></li></ul><h5 id="write"><a href="#write" class="headerlink" title="write"></a>write</h5><p>ssize_t write(int fd,void *buf,size_t count);</p><ul><li>参数:<ul><li>fd: 文件描述符</li><li>buf: 待写出数据的缓冲区</li><li>count: 数据大小</li></ul></li><li>返回值<ul><li>成功: 写入的字节数</li><li>失败: -1，设置errno</li></ul></li></ul><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><p>PCB 进程控制块:本质 结构体<br>成员: 文件描述符表<br>文件描述符: 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4&#x2F; … &#x2F;1023<br>0 - STDIN_FILENO<br>1 - STDOUT_FILENO<br>2 - STDERR_FILENO</p><h4 id="阻塞非阻塞"><a href="#阻塞非阻塞" class="headerlink" title="阻塞非阻塞"></a>阻塞非阻塞</h4><p>产生阻塞的场景: 读设备文件，读网络文件。<br>&#x2F;dev&#x2F;tty –终端文件</p><h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><p>int flags &#x3D; fcntl(fd,f_GETFL);</p><ul><li>获取文件状态: F_FETFL</li><li>设置文件状态：F_SETFL</li></ul><h4 id="link-unlink"><a href="#link-unlink" class="headerlink" title="link&#x2F;unlink"></a>link&#x2F;unlink</h4><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p>off_t lseek(int fd,off_t offset,int whence)</p><ul><li><p>参数</p><ul><li>fd: 文件描述符</li><li>offset: 偏移量</li><li>whence: 起始偏移量,(SEEK_SET|SEEK_CUR|SEEK_END)</li></ul></li><li><p>返回值:</p><ul><li>成功: 较起始位置偏移量</li><li>失败: -1 error</li></ul></li><li><p>应用场景:</p><ul><li><ol><li>文件的读写使用同一偏移量</li></ol></li><li><ol start="2"><li>使用lseek获取文件大小</li></ol></li><li><ol start="3"><li>使用lseek拓展文件大小，要想使文件大小真正拓展，必须引起IO操作</li></ol><ul><li>使用truncate直接拓展 int ret &#x3D; truncate(“dict.c”,250);</li></ul></li></ul></li></ul><h4 id="stat-lstat-函数"><a href="#stat-lstat-函数" class="headerlink" title="stat&#x2F;lstat 函数"></a>stat&#x2F;lstat 函数</h4><p>int stat(const char*path,struct stat *buf);</p><ul><li>参数:<ul><li>path:文件路径</li><li>buf:(传出参数) 存放文件属性</li></ul></li><li>返回值<ul><li>成功: 0</li><li>失败: -1</li></ul></li><li>获取文件大小: buf.st_size</li><li>获取文件类型: buf.st_mode</li><li>获取文件权限: cuf.st_mode</li><li>符号穿透: stat会,lstat不会</li></ul><h4 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* DIR* opendir(char *name)</span><br><span class="line">* int closedir(DIR *dp)</span><br><span class="line">* struct dirent *readdir(DIR *name);</span><br><span class="line">* struct dirent</span><br><span class="line">  &#123;</span><br><span class="line">    inode;</span><br><span class="line">    char name[256];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>pid_t fork(void)</p><ul><li>创建子进程。父子进程各自返回。父进程返回子进程pid。子进程返回0</li><li>getpid()</li><li>getppid()</li><li>循环创建n个子进程模型，每个子进程标识自己的身份</li></ul><p>父子进程相同：</p><ul><li>data</li><li>text</li><li>堆</li><li>栈</li><li>环境变量</li><li>全局变量</li><li>宿主目录位置</li><li>进程工作目录位置</li><li>信号处理方式</li></ul><p>父子进程不同：</p><ul><li>进程id</li><li>返回值</li><li>各自的父进程</li><li>进程创建的时间</li><li>闹钟</li><li>未决信号集</li></ul><h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><ul><li>设置父进程调试路径：set follow-fork-mode parent （默认）</li><li>设置子进程调试路径: set follow-fork-mode child</li></ul><h5 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h5><p>int execlp(const char*file,const char* argv)</p><ul><li>哨兵:NULL</li></ul><p>int execl(const char*file,const char* arg)</p><h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p>pid_wait(int *status)</p><ul><li>函数作用1:阻塞等待子进程退出</li><li>函数作用2:清理子进程残留在内核的pcb资源</li><li>函数作用3:通过传出参数,得到子进程结束状态</li></ul><h5 id="wait-pid"><a href="#wait-pid" class="headerlink" title="wait_pid"></a>wait_pid</h5><p>pid_t waitpid(pid_t pid,int *status,int options)</p><p>返回值:</p><ul><li>&gt;0:表示成功回收子进程的pid</li><li>0:函数调用时,参数3指定了WNOHANG,并且,没有子进程结束</li><li>-1:失败 error</li></ul><h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p>实现原理:内核借助环形队列机制,使用内核缓冲区实现<br>特质: </p><ol><li>伪文件</li><li>管道中的数据只能一次读取</li><li>数据在管道中,只能单向流动</li></ol><p>局限性:</p><ol><li>自己写不能自己读</li><li>数据不可以反复读</li><li>半双工通信</li><li>血缘关系进程间可用</li></ol><p>int pipe(int fd[2])</p><ul><li>fd[0]:读端</li><li>fd[1]:写端</li></ul><p>返回值:</p><ul><li>成功:0</li><li>失败:1 errno</li></ul><p>管道的读写行为</p><p>读管道:</p><ol><li>管道有数据,read返回实际读到的字节数</li><li>管道无数据:<ol><li>无写端:read返回0</li><li>有写端:read阻塞等待</li></ol></li></ol><p>写管道:</p><ol><li>无读端: 异常终止(SIGPIPE)</li><li>有读端:<ol><li>管道已满:阻塞等待</li><li>管道未满:返回写出的字节个数</li></ol></li></ol><h2 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h2><h3 id="本地字节序和网络字节序"><a href="#本地字节序和网络字节序" class="headerlink" title="本地字节序和网络字节序"></a>本地字节序和网络字节序</h3><h3 id="多路I-O转接"><a href="#多路I-O转接" class="headerlink" title="多路I&#x2F;O转接"></a>多路I&#x2F;O转接</h3><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><ul><li><p>int epoll_create(int size);</p><ul><li>size: 创建的红黑树的监听节点大小</li><li>返回值： 指向创建的根节点fd</li></ul></li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p><ul><li>epfd：根节点fd</li><li>op：所做的操作<ul><li>EPOLL_CTL_ADD</li><li>EPOLL_CTL_MOD</li><li>EPOLL_CTL_DEL</li></ul></li><li>fd：待监听fd</li><li>event：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>     events;      <span class="comment">/* EPOLLIN EPOLLOUT EPOLLERR*/</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">uint32_t</span>     u32;</span><br><span class="line">    <span class="type">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></li><li>返回值：成功0，失败-1</li></ul></li><li><p>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</p><ul><li>epfd：根节点fd</li><li>events：数组（传出参数） 传出满足条件的结构体</li><li>maxevents：数组元素的总个数</li><li>timeout <ul><li>-1：阻塞</li><li>0：不阻塞</li><li>&gt;0：超时时间</li></ul></li><li>返回值：<ul><li>&gt;&#x3D;0：满足监听事件的总个数</li><li>-1：失败</li></ul></li></ul></li><li><p>ET和LT</p><ul><li>水平触发（LT）是只要读缓冲区有数据，就会一直触发可读信号</li><li>边缘触发（ET）仅仅在空变为非空的时候通知一次</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/02/24/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/02/24/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><ul><li>一些优化(某些卡常的题有奇效)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">****<span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-labels&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdevirtualize&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcaller-saves&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcrossjumping&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fthread-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fwhole-program&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-tail-merge&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-aliasing&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-overflow&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-skip-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-follow-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-interblock&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpartial-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-findirect-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fhoist-adjacent-loads&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-frerun-cse-after-loop&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-finline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-switch-conversion&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-foptimize-sibling-calls&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fexpensive-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funsafe-loop-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions-called-once&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdelete-null-pointer-checks&quot;</span>)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ul><li>n &lt;&#x3D; 30 指数级别 dfs+剪枝 状态压缩dp</li><li>n &lt;&#x3D; 100 O(n^3) floyd dp</li><li>n &lt;&#x3D; 1000 O(n^2) O(n^2logn) dp dijkstra，二分</li><li>n &lt;&#x3D; 10^4 O(n*sqrt(n)) 块状链表</li><li>n &lt;&#x3D; 10^5 O(nlogn) 各种sort，线段树，树状数组，set&#x2F;map，heap，dijkstra+heap，spfa，求凸包，求半平面交，二分</li><li>n &lt;&#x3D; 10^6 O(n) 和常数较小的O(nlogn) hash，双指针，kmp，ac自动机，常数比小的O(nlogn)的做法：sort，树状数组，heap，dijkstra，spfa</li><li>n &lt;&#x3D; 10^7 O(n) 双指针，kmp，ac自动机，线性筛</li><li>n &lt;&#x3D; 10^9 O(sqrt(n)) 判断质数</li><li>n &lt;&#x3D; 10^18 最大公约数</li></ul><h4 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> x = a[l];</span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> ++i;<span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> --j;<span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quick_sort</span>(a,l,j); <span class="comment">//注意划分边界 用j</span></span><br><span class="line"><span class="built_in">quick_sort</span>(a,j + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(a,l,mid);<span class="comment">//注意边界取法</span></span><br><span class="line"><span class="built_in">merge_sort</span>(a,mid + <span class="number">1</span>,r);</span><br><span class="line"><span class="type">int</span> i = l,j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt; a[j]) tmp[cur++] = a[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[cur++] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid) tmp[cur++] = a[i++];</span><br><span class="line"><span class="keyword">while</span>(j &lt;= r) tmp[cur++] = a[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l,cur = <span class="number">0</span>;i &lt;= r;++i,++cur) a[i] = tmp[cur];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><h6 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [l,mid] [mid+1,r]</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [l,mid - 1] [mid,r]</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &lt;= x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> l = <span class="number">0</span>,r = x;</span><br><span class="line"><span class="keyword">while</span>(r - l &gt; <span class="number">1e-6</span>) <span class="comment">//精度为10^-4（一般比精度高2位）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x &gt;= mid*mid) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h5><ul><li>在c++中，我们采用数组存储大整数<br>&#x3D;&#x3D;采用倒序存储的方式比较好&#x3D;&#x3D;</li></ul><h6 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C; </span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line"><span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只需要最终结果时，可以直接采用这一版本</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> n_a = a.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> n_b = b.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n_a || i &lt; n_b;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; n_a) t += (a[n_a - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(i &lt; n_b) t += (b[n_b - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i] != B[i]) <span class="keyword">return</span> A[i] &gt;B[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">t = A[i] - t;</span><br><span class="line"><span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); </span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">&#123;</span><br><span class="line"> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A x b (高精度 x 低精度)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i]*b;</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A x B (高精度 x 高精度)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(A.size() + B.size())</span></span>;</span><br><span class="line">  LL t = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; B.<span class="built_in">size</span>();++j)</span><br><span class="line">C[i + j] += A[i]*B[j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>;i &lt; C.<span class="built_in">size</span>();++i)</span><br><span class="line">  &#123;</span><br><span class="line">  t += C[i];</span><br><span class="line">  C[i] = t % <span class="number">10</span>;</span><br><span class="line">  t /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C....r (高精度 除以 低精度)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">//为了与前面统一，这里还是采用倒序存储的方式</span></span><br><span class="line">&#123;</span><br><span class="line">r = r * <span class="number">10</span> + A[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">r %= b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><h6 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求前缀数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br></pre></td></tr></table></figure><h6 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求前缀数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">&#123;</span><br><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x2][y1 - <span class="number">1</span>] -s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]); </span><br></pre></td></tr></table></figure><h5 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h5><h6 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[l] += c;</span><br><span class="line">b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化构造</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i &lt;= n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="built_in">insert</span>(i,i,a[i]);</span><br></pre></td></tr></table></figure><h6 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[x1][y1] += c;</span><br><span class="line">b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化构造</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(j &lt; i &amp;&amp; <span class="built_in">check</span>(i,j)) ++j;</span><br><span class="line"><span class="comment">/*具体逻辑*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一道题目来说明<br><img src="/../images/lisan.png" alt="区间和 + 离散化"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add;</span><br><span class="line">vector&lt;PII&gt; query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, c;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; c;;</span><br><span class="line">add.<span class="built_in">push_back</span>(&#123; x,c &#125;);</span><br><span class="line">alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;  </span><br><span class="line">cin&gt;&gt; x &gt;&gt; y;</span><br><span class="line">query.<span class="built_in">push_back</span>(&#123; x,y &#125;);</span><br><span class="line">alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">alls.<span class="built_in">push_back</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">a[x] += item.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="built_in">find</span>(item.first);</span><br><span class="line"><span class="type">int</span> r = <span class="built_in">find</span>(item.second);</span><br><span class="line">cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">vector&lt;PII&gt; seg, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a &gt;&gt; b, seg.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(seg.<span class="built_in">begin</span>(), seg.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> l = seg[<span class="number">0</span>].first, r = seg[<span class="number">0</span>].second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seg.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seg[i].first &gt; r) res.<span class="built_in">push_back</span>(&#123;l, r&#125;), l = seg[i].first, r = seg[i].second;</span><br><span class="line">        <span class="keyword">else</span> r = <span class="built_in">max</span>(r, seg[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////头部插入结点 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_head</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = a,ne[idx] = head,head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标为k的后面地方插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = val;</span><br><span class="line">ne[idx] = ne[k];</span><br><span class="line">ne[k] = idx;</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移去下标k后面 的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line"> <span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">idx = <span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// k的右边插入 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">r[idx] = r[k];</span><br><span class="line">l[idx] = k;</span><br><span class="line">l[r[k]] = idx;  <span class="comment">//注意顺序 </span></span><br><span class="line">r[k] = idx;   </span><br><span class="line">++idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add(l[k],x) 可实现k的左边的插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r[l[k]] = r[k];</span><br><span class="line">l[r[k]] = l[k];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt; tt &amp;&amp; <span class="built_in">check</span>(q[tt - <span class="number">1</span>], i)) tt -- ;   <span class="comment">// 维护窗口内的某种性质</span></span><br><span class="line">    q[tt++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>,M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> p[M],s[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//求ne数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; p[j + <span class="number">1</span>] != p[i]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span>(p[j + <span class="number">1</span>] == p[i]) ++j;</span><br><span class="line">ne[i] = j; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) ++j;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(j == m) &#123;</span><br><span class="line"><span class="comment">//匹配成功的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">800000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>],idx;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][u]) trie[p][u] = ++idx;</span><br><span class="line">p = trie[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = trie[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">find</span>(x);</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(size[a] &gt; size[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">fa[a] = b;</span><br><span class="line">size[b] += size[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><ul><li>归根结底，记住两种操作即可<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>((u &gt;&gt; <span class="number">1</span>) &amp;&amp; h[u &gt;&gt; <span class="number">1</span>] &gt; h[u]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(h[u &gt;&gt; <span class="number">1</span>],h[u]);</span><br><span class="line">u = u &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">2</span>*u;</span><br><span class="line"><span class="type">int</span> r = <span class="number">2</span>*u + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= size &amp;&amp; h[l] &lt; h[t]) t = l;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= size &amp;&amp; h[r] &lt; h[t]) t = r;</span><br><span class="line"><span class="keyword">if</span>(u != t) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(h[t],h[u]);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>基于以上两种操作实现<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">h[++size] = val;</span><br><span class="line"><span class="built_in">up</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除最小值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_min</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">h[<span class="number">1</span>] = h[size--];</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除任意一个冤元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[k] = heap[size--];</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改任意一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">heap[k] = val;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ul><li>注意均需要初始化</li></ul><h6 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拉链法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],ne[N],e[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = h[k];</span><br><span class="line">h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[k];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开放寻址法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> null = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,null,<span class="built_in">sizeof</span>(null));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回可以插入的槽位</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line"><span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span>(k == N) k = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h6><ul><li>巧妙设置 p &#x3D; 131 或 p &#x3D; 13331 ，N &#x3D; 2^64 可有效避免hash碰撞</li><li>把hash[] 大小定义为ULL，超过则自动溢出<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串哈希</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>,P = <span class="number">131</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line">ULL p[N],h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">p[i + <span class="number">1</span>] = p[i]*P;</span><br><span class="line">h[i + <span class="number">1</span>] = h[i] * P + s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ULL <span class="title">get_substr</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>]*p[l - r + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><ul><li>一般需要找出解空间树<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> u)</span> <span class="comment">//u代表层数，其它参数可灵活设置可以设置一些表示当前结点状态的参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(到达树的底端)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//收集结果</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(每一子节点)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(未被标记) <span class="comment">//一般还需考虑根节点的标记永久设置为以访问，以防出错</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//做出选择</span></span><br><span class="line"><span class="comment">//设置为已标记</span></span><br><span class="line"><span class="comment">//dfs(u + 1)</span></span><br><span class="line"><span class="comment">//撤销选择</span></span><br><span class="line"><span class="comment">//改为未被标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="图的dfs"><a href="#图的dfs" class="headerlink" title="图的dfs"></a>图的dfs</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图的bfs"><a href="#图的bfs" class="headerlink" title="图的bfs"></a>图的bfs</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="flood-fill"><a href="#flood-fill" class="headerlink" title="flood fill"></a>flood fill</h6><ul><li>求连通块的面积、块数等</li></ul><h6 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h6><ul><li>只包含两种距离的最短路</li><li>多源最短路</li></ul><h6 id="最小步数"><a href="#最小步数" class="headerlink" title="最小步数"></a>最小步数</h6><ul><li>双向广搜<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string start,ed;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,string&gt; PIS;</span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;da,db;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt;&amp;q,unordered_map&lt;string,<span class="type">int</span>&gt;&amp;da,unordered_map&lt;string,<span class="type">int</span>&gt;&amp;db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> s = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(db.<span class="built_in">count</span>(s)) <span class="keyword">return</span> db[s] + da[s];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = s.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="type">int</span> x = k / <span class="number">3</span>,y = k % <span class="number">3</span>;</span><br><span class="line">string source = s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = dx[i] + x,b = dy[i] + y;</span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= <span class="number">3</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(s[a*<span class="number">3</span> + b],s[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(da.<span class="built_in">count</span>(s) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">da[s] = da[source] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;s&#125;);</span><br><span class="line">&#125;</span><br><span class="line">s = source;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == ed) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;qa,qb;</span><br><span class="line">qa.<span class="built_in">push</span>(&#123;start&#125;),qb.<span class="built_in">push</span>(&#123;ed&#125;);</span><br><span class="line">da[start] = <span class="number">0</span>,db[ed] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(qa.<span class="built_in">size</span>() &gt; qb.<span class="built_in">size</span>()) res = <span class="built_in">extend</span>(qb,db,da);</span><br><span class="line"><span class="keyword">else</span> res = <span class="built_in">extend</span>(qa,da,db);</span><br><span class="line"><span class="keyword">if</span> (res &gt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; start;</span><br><span class="line">ed = <span class="string">&quot;123804765&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string start,ed;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,string&gt; PIS;</span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;da,db;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt;&amp;q,unordered_map&lt;string,<span class="type">int</span>&gt;&amp;da,unordered_map&lt;string,<span class="type">int</span>&gt;&amp;db)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m = q.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> s = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(db.<span class="built_in">count</span>(s)) <span class="keyword">return</span> db[s] + da[s];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = s.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="type">int</span> x = k / <span class="number">3</span>,y = k % <span class="number">3</span>;</span><br><span class="line">string source = s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = dx[i] + x,b = dy[i] + y;</span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= <span class="number">3</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(s[a*<span class="number">3</span> + b],s[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(da.<span class="built_in">count</span>(s) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">da[s] = da[source] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;s&#125;);</span><br><span class="line">&#125;</span><br><span class="line">s = source;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == ed) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;qa,qb;</span><br><span class="line">qa.<span class="built_in">push</span>(&#123;start&#125;),qb.<span class="built_in">push</span>(&#123;ed&#125;);</span><br><span class="line">da[start] = <span class="number">0</span>,db[ed] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(qa.<span class="built_in">size</span>() &gt; qb.<span class="built_in">size</span>()) res = <span class="built_in">extend</span>(qb,db,da);</span><br><span class="line"><span class="keyword">else</span> res = <span class="built_in">extend</span>(qa,da,db);</span><br><span class="line"><span class="keyword">if</span> (res &gt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; start;</span><br><span class="line">ed = <span class="string">&quot;123804765&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A*</li></ul><h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于拓扑序要求不能有换=环，所以不需要st数组来记录</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">top_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>,hh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line"><span class="keyword">if</span>(!d[i]) </span><br><span class="line">&#123;</span><br><span class="line">q[tt++] = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(hh &lt; tt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = q[hh++] ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[v];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = e[i];</span><br><span class="line">d[u]--;</span><br><span class="line"><span class="keyword">if</span>(!d[u]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, u);</span><br><span class="line">q[tt++] = u;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><h5 id="最短路-1"><a href="#最短路-1" class="headerlink" title="最短路"></a>最短路</h5><h6 id="dijkstra（适合稠密图的单源最短路）"><a href="#dijkstra（适合稠密图的单源最短路）" class="headerlink" title="dijkstra（适合稠密图的单源最短路）"></a>dijkstra（适合稠密图的单源最短路）</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化距离</span></span><br><span class="line"><span class="comment">// 2. for v 1~n 迭代</span></span><br><span class="line"><span class="comment">//找到距离源点最短的点t，肯定为以确定，做上标记</span></span><br><span class="line"><span class="comment">//更新所有能更新的点的距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span> <span class="comment">//源点为s</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">//t的初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (d[j] &lt; d[t] || t == <span class="number">-1</span>)) t = j;</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">&#123;</span><br><span class="line">d[j] = <span class="built_in">min</span>(d[j],d[t] + g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="dijkstra堆优化-适合稀疏图"><a href="#dijkstra堆优化-适合稀疏图" class="headerlink" title="dijkstra堆优化(适合稀疏图)"></a>dijkstra堆优化(适合稀疏图)</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line">priority_queue &lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; <span class="comment">//最小堆的初始化方法</span></span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line"><span class="keyword">while</span>(!heap.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> u= t.second;</span><br><span class="line"><span class="keyword">if</span>(st[u]) <span class="keyword">continue</span>; <span class="comment">//注意st的判断时机</span></span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(d[v] &gt; d[u] + w[i])</span><br><span class="line">&#123;</span><br><span class="line">d[v] = d[u] + w[i];</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;d[v],v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span>(d[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求s到n的最短路距离，如果无法从s走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">st[s] = <span class="literal">true</span>; <span class="comment">//st表示点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[u] = <span class="literal">false</span>; <span class="comment">//注意此步 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(d[v] &gt; d[u] + w[i]) </span><br><span class="line">&#123;</span><br><span class="line">d[v] = d[u] + w[i];</span><br><span class="line"><span class="keyword">if</span>(!st[v]) <span class="comment">//注意此步很容易写少 </span></span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">st[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断负环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    st[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[j] &gt; d[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;      <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><h6 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || d[t] &gt; d[j])) t = j;</span><br><span class="line">&#125;</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i &amp;&amp; d[t] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(i) res += d[t]; <span class="comment">//先累加再更新，顺序不能乱</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">&#123;</span><br><span class="line">d[j] = <span class="built_in">min</span>(d[j],g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="krustal"><a href="#krustal" class="headerlink" title="krustal"></a>krustal</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Edge &amp;a,<span class="type">const</span> Edge&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Edge e[M];</span><br><span class="line"><span class="type">int</span> fa[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa[x] != x) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">krustal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;++i) fa[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(e,e + m,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">find</span>(e[i].a),b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line"><span class="keyword">if</span>(a != b) </span><br><span class="line">&#123;</span><br><span class="line">fa[a] = b;</span><br><span class="line">res += e[i].c;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h5><h6 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color[u] = c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(!color[v]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(v,<span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[v] == color[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="匈牙利算法求最大匹配"><a href="#匈牙利算法求最大匹配" class="headerlink" title="匈牙利算法求最大匹配"></a>匈牙利算法求最大匹配</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(st[v]) <span class="keyword">continue</span>;</span><br><span class="line">st[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!match[v] || <span class="built_in">dfs</span>(match[v]))</span><br><span class="line">&#123;</span><br><span class="line">match[v] = u;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_res</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);  <span class="comment">//最容易漏的一步 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ++ res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h4><h5 id="判断质数"><a href="#判断质数" class="headerlink" title="判断质数"></a>判断质数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性筛法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> prime[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i]) prime[cnt++] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;<span class="number">1ll</span>*i*prime[j] &lt;= n;++j) <span class="comment">//用ll型转换防止爆int </span></span><br><span class="line">&#123;</span><br><span class="line">st[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//1. 如果i是合数，最多枚举到最小的质因数停止即可</span></span><br><span class="line"><span class="comment">//2  如果i是质数，最多枚举到本身即可 </span></span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h5><ol><li>若i是质数，a[i] &#x3D; 1,d[i] &#x3D; 2</li><li>在线性筛中，每个合数m都是被最小的质因子筛掉的。设pj是m的最小质因子，则m通过m &#x3D; pj x i 筛掉<ul><li>若i能被pj整除，则pj一定是i的最小质因子。 <ul><li>a[m] &#x3D; a[i] + 1</li><li>d[i] &#x3D; (a[i] + 1) x …,d[m] &#x3D; (a[m] + 1) x …</li></ul></li><li>若i不能被pj整除，则i不包含质因子pj<ul><li>a[m] &#x3D; 1,d[m] &#x3D; d[i] x (1 + 1)</li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>; </span><br><span class="line"><span class="comment">// a[i] 表示i的最小质因数次数</span></span><br><span class="line"><span class="comment">// d[i] 表示i的约数个数</span></span><br><span class="line"><span class="type">int</span> prime[N],a[N],d[N],cnt; </span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!st[i]) </span><br><span class="line">&#123;</span><br><span class="line">prime[++cnt] = i;</span><br><span class="line">a[i] = <span class="number">1</span>;</span><br><span class="line">d[i] = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;<span class="number">1ll</span>*prime[j]*i &lt;= n;++j)</span><br><span class="line">&#123;</span><br><span class="line">st[prime[j]*i] = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> m = i * prime[j];</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[m] = a[i] + <span class="number">1</span>;</span><br><span class="line">d[m] = d[i]/a[m] * (a[m] + <span class="number">1</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">a[m] = <span class="number">1</span>;</span><br><span class="line">d[m] = <span class="number">2</span> * d[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="筛法求约数和"><a href="#筛法求约数和" class="headerlink" title="筛法求约数和"></a>筛法求约数和</h5><ol><li>若i是质数，g[i] &#x3D; f[i] &#x3D; i + 1</li><li>在线性筛中，每个合数m都是被最小的质因子筛掉的。设pj是m中的最小质因子，则m通过m &#x3D; i x pj 筛掉<ul><li><p>若i能被pj整除，则pj一定也是i的最小质因子</p><ul><li>g[i] &#x3D; pj^0 + pj^1 + … + pj^bj</li><li>g[m] &#x3D; pj^0 + pj^1 + … + pj^bj + pj^(bj + 1)</li><li>f[i] &#x3D; g[i] x …</li><li>f[m] &#x3D; g[m] x …</li></ul></li><li><p>若不能被pj整除，则i不包含质因子pj</p><ul><li>g[m] &#x3D; pj + 1;</li><li>f[m] &#x3D; g[m] x f[i]</li></ul></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">//1. g[i] 表示 i 的最小质因数的 pj^0 + pj^1 + ... + pj^bj</span></span><br><span class="line"><span class="comment">//2. f[i] 表示 i 的质因数之和</span></span><br><span class="line"><span class="type">int</span> g[N],f[N],prime[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i])</span><br><span class="line">&#123;</span><br><span class="line">prime[++cnt] = i;</span><br><span class="line">g[i] = i + <span class="number">1</span>;</span><br><span class="line">f[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;i * prime[j] &lt;= n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m = i * prime[j];</span><br><span class="line">st[m] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">g[m] = g[i]*prime[j] + <span class="number">1</span>;</span><br><span class="line">f[m] = f[i]/g[i]*g[m];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">g[m] = prime[j] + <span class="number">1</span>;</span><br><span class="line">f[m] = g[m] * f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><h5 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h5><ul><li>最多花费<ul><li>max:一般无需初始化</li><li>min:全初始化为无穷大，f[0] &#x3D; 0</li><li>方案数：全初始化为1,f[0 ~ n] &#x3D; 1</li></ul></li><li>最少花费<ul><li>max:全部初始化为 -inf 或 -1 , f[-k ~ 0] &#x3D; 1</li><li>min:全部初始化为 inf , f[-k ~ 0] &#x3D; 1</li></ul></li><li>恰好花费<ul><li>max:max:全部初始化为 -inf 或 -1 , f[0] &#x3D; 1</li><li>min:全部初始化为 inf , f[0] &#x3D; 1</li><li>方案数：f[0] &#x3D; 1</li></ul></li></ul><h5 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* 基本思路</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//特判 </span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">while</span>(n) nums.<span class="built_in">push_back</span>(n % b),n /= b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
