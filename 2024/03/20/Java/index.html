<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | 半夏琉璃空</title><meta name="author" content="听灵"><meta name="copyright" content="听灵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="省略许多很基础的东西，主要记录一些Java语言特有的特性，未更完… 一些技巧 1. 断点调试  快捷键介绍:  F7(跳入) 如果不成功，可通过File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger -&gt; Stepping,将java.*和javax.*强制取消勾选 F8(跳过) shift + F8(跳出)">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2024/03/20/Java/index.html">
<meta property="og:site_name" content="半夏琉璃空">
<meta property="og:description" content="省略许多很基础的东西，主要记录一些Java语言特有的特性，未更完… 一些技巧 1. 断点调试  快捷键介绍:  F7(跳入) 如果不成功，可通过File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger -&gt; Stepping,将java.*和javax.*强制取消勾选 F8(跳过) shift + F8(跳出)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/ava.jpg">
<meta property="article:published_time" content="2024-03-20T05:18:29.000Z">
<meta property="article:modified_time" content="2024-05-25T12:11:11.855Z">
<meta property="article:author" content="听灵">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/ava.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/03/20/Java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-25 20:11:11'
}</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg" style="background-color: #efefef;"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">半夏琉璃空</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-20T05:18:29.000Z" title="发表于 2024-03-20 13:18:29">2024-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-25T12:11:11.855Z" title="更新于 2024-05-25 20:11:11">2024-05-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>省略许多很基础的东西，主要记录一些Java语言特有的特性，未更完…</p>
<h4 id="一些技巧">一些技巧</h4>
<h6 id="1-断点调试">1. 断点调试</h6>
<ul>
<li>快捷键介绍:
<ul>
<li>F7(跳入) <em>如果不成功，可通过File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger -&gt; Stepping</em>,将java.*和javax.*强制取消勾选</li>
<li>F8(跳过)</li>
<li>shift + F8(跳出)</li>
<li>F9(resume,执行到下一个断点)</li>
</ul>
</li>
</ul>
<h3 id="java基础">java基础</h3>
<h5 id="1-jdk与jre">1. JDK与JRE</h5>
<ul>
<li>JDK=JRE+开发工具集(javac,java编译工具等)</li>
<li>JRE=JVM+JAVA SE标准类库(java核心类库)</li>
<li>注:如果只是想运行开发好的.class文件,只需JRE</li>
</ul>
<h5 id="2-文档注释">2. 文档注释</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> baiyue</span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用法：javadoc -d 生成的文件名 -version -author xxx.java</p>
<h5 id="3-java中的变量细节">3. Java中的变量细节</h5>
<p>转换机制：有两条。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(char)--&gt;b(int)--&gt;c(long)--&gt;d(float)--&gt;e(double)</span><br><span class="line">f(byte)--&gt;s(short)--&gt;b</span><br></pre></td></tr></table></figure>
<p><em>细节</em></p>
<ul>
<li>基本满足小到大可自动转换，大到小就不行</li>
<li>当有多种数据类型混和运算时，转换为最大的数据类型</li>
<li>byte short 和char之间不能相互自动转换,例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b1=<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c1=b1;<span class="comment">//错误,之间不能自动转换</span></span><br></pre></td></tr></table></figure>
<ul>
<li>byte,short,char 他们三者可以计算,在计算时首先转换为int型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> b2 + s1;<span class="comment">//错误,b2+s1 =&gt; int</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> b3 + b2;<span class="comment">//非常容易忽略,原理同上,b2+b3会自动转换为int</span></span><br><span class="line"><span class="type">short</span> s=s1+<span class="number">1</span>;<span class="comment">//错误,s1+1为int类型</span></span><br></pre></td></tr></table></figure>
<h5 id="4-强制数据类型转换">4. 强制数据类型转换</h5>
<p><em>细节</em>(阐述的都是一些容易犯错的细节)</p>
<ul>
<li>char类型可以保存int常量型,但不能保存int变量值,需要强转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c1=<span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> m=<span class="number">100</span>;<span class="comment">//ok</span></span><br><span class="line"><span class="type">char</span> c2=m;<span class="comment">//false</span></span><br><span class="line"><span class="type">char</span> c3=<span class="type">char</span>(m);<span class="comment">//ok,输出100ASCIll对应的字符</span></span><br></pre></td></tr></table></figure>
<h5 id="5-java中的运算符细节">5. java中的运算符细节</h5>
<ul>
<li>在取模运算中,Java与c有不同,c只能对整数取模,而java可以对小数取模,例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=-<span class="number">10.5</span>%<span class="number">3</span>;<span class="comment">//c中会报错,而在Java中显示-1.5,当然精度会有所损失</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自增运算符i++理解&lt;==&gt;temp=i;i=i+1;temp=i;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">i=i++;<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<h5 id="6-进制表示">6. 进制表示</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1=<span class="number">1010</span>;  <span class="comment">//1010 十进制</span></span><br><span class="line"><span class="type">int</span> n2=<span class="number">01010</span>; <span class="comment">//520 8进制</span></span><br><span class="line"><span class="type">int</span> n3=<span class="number">0b1010</span>; <span class="comment">//10 2进制 </span></span><br><span class="line"><span class="type">int</span> n4=<span class="number">0x1010</span>; <span class="comment">//4112 16进制</span></span><br><span class="line">System.out.println(n1+<span class="string">&quot;\n&quot;</span>+n2+<span class="string">&quot;\n&quot;</span>+n3+<span class="string">&quot;\n&quot;</span>+n4);</span><br></pre></td></tr></table></figure>
<p>三元运算符细节：把整个看成一个整体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>?<span class="number">1</span>:<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//a = 1.0;</span></span><br></pre></td></tr></table></figure>
<h5 id="6-关于数组">6. 关于数组</h5>
<p>==与c不同，java的数组是引用类型，本质是对象，所以有自己的赋值机制。==</p>
<ul>
<li>在而二维数组中,每行的列数可不等,这里比较灵活,例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">			a[i]=<span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;++j)&#123;</span><br><span class="line">				a[i][j]=i+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a[i].length;++j)&#123;</span><br><span class="line">				System.out.println(a[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 输出:  1</span></span><br><span class="line"><span class="comment">//       2 2</span></span><br><span class="line"><span class="comment">//       3 3 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">int</span>[][] a = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>还需注意二维数组的声明方式有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][];</span><br><span class="line"><span class="type">int</span>[] a[];</span><br><span class="line"><span class="type">int</span>[][] a;</span><br></pre></td></tr></table></figure>
<p>这就会产生一些细节问题,如以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] x,y[];<span class="comment">//x是一维数组,y是二维数组</span></span><br></pre></td></tr></table></figure>
<p>对string数组的声明细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="面向对象编程">面向对象编程</h3>
<h4 id="一-java初级">一. Java初级</h4>
<h6 id="关于方法重载注意事项">关于方法重载注意事项</h6>
<ol>
<li>函数名必须相同</li>
<li>返回类型无要求</li>
<li>形参列表至少有一项不同</li>
</ol>
<h6 id="可变参数">可变参数</h6>
<ul>
<li>Java中允许将同一个类中多个同名但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HspMethod</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">			res+=nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. int... 表示接收的是可变参数,类型是int,既可以接收多个int(0-多)</span></span><br><span class="line"><span class="comment">//2. 使用可变参数是,应该当作数组使用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><em>注意细节</em></li>
</ul>
<ol>
<li>可变参数的实参可以是0或任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>一个形参列表只能有一个可变参数</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数放在最后</li>
</ol>
<h6 id="关于作用域">关于作用域</h6>
<p>在java中，全局变量一般指属性，而局部变量一般指方法中定义的变量。<br>
<em>一个小细节，全局变量可以不赋值，直接使用；而局部变量必须赋值后，才能使用，因为没有默认值</em></p>
<h6 id="构造器">构造器</h6>
<ul>
<li><em>注意细节</em></li>
</ul>
<ol>
<li>如果使用者没有定义构造方法，系统会自动生成一个默认无参的构造方法（也称为默认构造方法）==可以使用javap指令反编译查看==</li>
<li>一旦定义自己的构造器，<strong>系统默认的构造器会被覆盖</strong>，无法使用默认构造器，除非再进行显示定义（构造器重载原理）</li>
</ol>
<h6 id="关于this">关于this</h6>
<ul>
<li>注意细节</li>
</ul>
<ol>
<li>this可以访问本类的属性、方法、构造器</li>
<li>访问成员变量的语法：this.（方法名）</li>
<li>访问构造器的语法:this(参数列表)(注意只能在构造器中使用)<br>
<em>即只能在构造器中访问另一个构造器</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>注：必须放置第一条语句</em></li>
</ul>
<ol start="4">
<li>this不能在类定义的外部使用，只能在类定义的方法中使用</li>
</ol>
<h4 id="二-java中级">二. java中级</h4>
<h6 id="1-包">1. 包</h6>
<ul>
<li>命名规则：只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">demo.class.exec1<span class="comment">//false,class is key word</span></span><br><span class="line">demo.12a <span class="comment">//false,12a is started with number</span></span><br><span class="line">demo.ab12.oa <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>命名规范:一般是小写字母加小圆点<br>
<em>com.公司名.项目名.业务模块名</em>,例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sina.crm.user <span class="comment">//用户模块</span></span><br><span class="line">com.sina.crm.order<span class="comment">//订单模块</span></span><br><span class="line">com.sina.crm.utils<span class="comment">//工具类</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Java中常用的包:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> java.lang <span class="comment">//基本包,默认引入</span></span><br><span class="line"><span class="number">2.</span> java.util <span class="comment">//系统提供的工具包,工具类,使用Scanner</span></span><br><span class="line"><span class="number">3.</span> java.net <span class="comment">//网络包,网络开发</span></span><br><span class="line"><span class="number">4.</span> java.awt <span class="comment">//java的界面开发</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用细节
<ol>
<li>package的作用是声明当前类所在的包,需要放在类的<strong>最上面</strong>,一个类最多只有一句package</li>
<li>import指令放在package的下面,类定义前,顺序无要求</li>
</ol>
</li>
</ul>
<h6 id="2-访问修饰符">2. 访问修饰符</h6>
<table>
<thead>
<tr>
<th>1</th>
<th>访问级别</th>
<th>修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>公开</td>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>3</td>
<td>受保护</td>
<td>protected</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>x</td>
</tr>
<tr>
<td>4</td>
<td>默认</td>
<td>无</td>
<td>✔</td>
<td>✔</td>
<td>x</td>
<td>x</td>
</tr>
<tr>
<td>5</td>
<td>私有</td>
<td>private</td>
<td>✔</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<ul>
<li>注意事项<br>
1. 只有默认和public可以修饰类,并且遵循上述访问权限的特点<br>
2. 成员方法的访问规则和属性完全一样</li>
</ul>
<h6 id="3-封装-encapsulation">3. 封装(encapsulation)</h6>
<ul>
<li>
<p>实现步骤</p>
<ol>
<li>将属性直接私有化(不能直接修改属性)</li>
<li>提供一个公共的(public)set方法,用于对属性判断并赋值</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXxx</span><span class="params">(类型 参数名)</span>&#123;</span><br><span class="line"> <span class="comment">//加入数据验证的逻辑</span></span><br><span class="line"> 属性=参数名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提供一个公共的get方法,用于获取属性的值</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> XX <span class="title function_">getXxx</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//权限判断</span></span><br><span class="line"> <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当使用构造器时，可以将方法调用写入构造器中，以维护其封装性</p>
</li>
</ul>
<h6 id="4-继承-extends">4. 继承(extends)</h6>
<p><em>细节问题</em></p>
<ul>
<li>子类构造器第一句话为super()</li>
<li>子类继承了父类的所有属性和方法,但私有属性和方法不能在子类直接访问,要通过<strong>父类提供的公共方法</strong></li>
<li>子类必须调用父类的构造器,完成父类的初始化.并且父类没有提供无参构造器,则必须在子类的构造器中用<strong>super</strong>去指定使用父类的哪个构造器完成对父类的初始化工作,否则编译不通过.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.entend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.entend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;我必须存在&quot;</span>);<span class="comment">//当父类没有无参构造器时，必须使用super指明调用父类的哪个构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果指定需要调用哪个构造器，那就显式调用一下</p>
</li>
<li>
<p><strong>super必须放在子类的第一行</strong></p>
</li>
<li>
<p>由于super()和this()都只能放在构造器内部第一行，所以两者不能同时使用</p>
</li>
<li>
<p>所有的类都继承自Object类</p>
</li>
<li>
<p>子类最多只能继承一个父类(指直接继承),即java是单继承机制</p>
</li>
<li>
<p>当类属性名字相同时，优先访问最近的祖先，如果期间有private，就会报错，不会跳过继续向上寻找</p>
</li>
<li>
<p>关于super</p>
<ul>
<li>当子类中有和父类中的成员(属性和方法)重名时,为了访问父类的成员,必须通过super.如果没有重名,使用this和super时一样的效果,也可以直接访问</li>
</ul>
</li>
<li>
<p>方法重写</p>
<ul>
<li>子类的方法的参数，方法名称，和父类方法的参数，方法名称完全一样</li>
<li>子类的返回类型个父类的返回类型一样，或者是父类返回类型的子类(如父类的返回类型是Object,子类的返回类型是String)</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> B <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;f方法被重写啦&quot;</span>);<span class="comment">//合理因为定义B是A的子类</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*方法重写和重载比较</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>形参列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>重载(overload)</td>
<td>本类</td>
<td>必须一样</td>
<td>类型,个数或者顺序至少有一个不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写(override)</td>
<td>父子类</td>
<td>必须一样</td>
<td>相同</td>
<td>子类重写的方法,返回类型和父类返回类型一致或者是其子类</td>
<td>子类方法不能缩小父类方法的访问范围</td>
</tr>
</tbody>
</table>
<h6 id="5-多态-polymorphic">5. 多态(polymorphic)</h6>
<ul>
<li>多态的细节
<ul>
<li>前提(两个对象(类)存在继承关系)</li>
<li>本质:父类的引用指向了子类的对象</li>
</ul>
</li>
</ul>
<p><strong>多态的向上转型</strong></p>
<ul>
<li>语法:父类类型 引用名 = new 子类类型()</li>
<li>特点:
<ol>
<li>可以调用父类所有成员(须遵循访问权限)</li>
<li>不能调用子类特有成员</li>
<li>最终运行效果看子类的具体实现,即调用方法时,按照子类(运行类型)开始查找方法,调用规则与之前一致</li>
</ol>
</li>
</ul>
<p><strong>多态的向下转型</strong></p>
<ul>
<li>语法:子类类型 引用名 = (子类类型) 父类引用</li>
<li>只能强转父类的应用,不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有的成员</li>
<li><strong>属性没有重写</strong>属性的值看编译类型!!!</li>
<li>instanceof,用于判断对象的运行类型是否为xx的子类型.</li>
</ul>
<p><strong>动态绑定机制</strong></p>
<ol>
<li>当调用对象方法的时候，该方法会会和该对象的内存地址/运行类型绑定</li>
<li>当调用对象属性时，没有该机制，哪里声明哪里使用</li>
</ol>
<h6 id="6-运算符">6. ==运算符</h6>
<ol>
<li>既可以判断基本类型,又可以判断引用类型</li>
<li>如果判断引用类型,判断地址是否相等</li>
</ol>
<h6 id="7-equals方法">7. equals方法</h6>
<p>只能判断引用类型，默认判断地址是否相等，子类中往往重写该方法，用来判断内容是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">System.out.println(p1.equals(p2));<span class="comment">//false，该类没有重写equals方法，默认调用Object类的方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类型判断</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span>(Person) obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age &amp;&amp; <span class="built_in">this</span>.gender == p.gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加该方法重写后，原输出为true</span></span><br></pre></td></tr></table></figure>
<h6 id="8-hashcode方法">8. hashCode方法</h6>
<p>地址不同值不同,本质是建立与地址的映射</p>
<h6 id="9-tostring方法">9. toString方法</h6>
<ul>
<li>默认返回: 全类名+@+哈希值的十六进制,子类往往重写该方法,用于返回对象的属性信息</li>
</ul>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重写后打印对象或拼接对象时,都会默认调用该对象的toString形式</li>
<li>当直接输出对象时,也会默认调用该方法</li>
<li>alt + insert可以重写</li>
</ul>
<h5 id="10-finalize方法">10. finalize方法</h5>
<ul>
<li>当对象被回收时,系统默认调用该对象的finalize方法.子类可以重写该方法,做一些释放资源的操作</li>
<li>什么时候被回收:当某个对象没有被引用时,则jvm认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁该对象,在销毁对象前,会先调用finalize方法</li>
<li>垃圾回收机制的调用,是由系统来决定的(有自己的GC算法),也可以通过System.gc()主动触发垃圾回收机制</li>
</ul>
<h4 id="三-java高级">三. java高级</h4>
<h5 id="1-类变量和类方法">1. 类变量和类方法</h5>
<h6 id="类变量">类变量</h6>
<ul>
<li>类变量即静态变量,是该类的所有对象共享的变量</li>
<li>定义语法: 访问修饰符 static 数据类型 变量名;</li>
<li>可直接通过类名.变量名直接访问(伴随着类的加载而创建,所以即使没有创建对象实例也可以访问)</li>
</ul>
<p><em>一些细节</em></p>
<ul>
<li>类变量/静态变量,实例变量/普通变量/非静态变量</li>
<li>类变量的生命周期是随类的加载开始,随着类的消亡而销毁</li>
</ul>
<h6 id="类方法">类方法</h6>
<ul>
<li>类方法也叫静态方法</li>
<li>形式: 访问修饰符 static 数据返回类型 方法名(){ }</li>
<li>类方法调用: 类名.类方法名</li>
</ul>
<p><em>一些细节</em></p>
<ul>
<li>类方法不允许使用和对象有关的关键字,比如this和super.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        static_.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.a);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类方法只能访问静态变量或静态方法</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">      hi();<span class="comment">//false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>普通成员方法既可访问普通变量(方法),也可以访问静态变量(方法)</li>
</ul>
<h5 id="2-main方法的语法说明">2. main方法的语法说明</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>main方法是虚拟机调用</li>
<li>java虚拟机需要调用类的main()方法,所以该方法的访问权限必须时public</li>
<li>java虚拟机在执行main()方法时不必创建对象,所以该方法必须是static</li>
<li>该方法接收String类型的数组参数,该数组中保存执行Java命令时传递给所运行的类的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java 执行的参数 参数<span class="number">1</span> 参数<span class="number">2</span> 参数<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>由此我们可以得出以下结论:</p>
<ul>
<li>在main()方法中,我们可以直接调用main方法所在类的静态方法或静态属性</li>
<li>==如果要访问该类中的静态成员,必须先创建该类的一个实例对象后,才能通过这个对象去访问类中的非静态成员==</li>
</ul>
<h5 id="3-代码块">3.代码块</h5>
<p>基本介绍:又称为初始化块,属于类中的成员(类中的一部分),类似于方法,将逻辑语句封装在方法体中,通过{}包围起来.<br>
但又和方法不同,没有<strong>方法名</strong>,没有<strong>返回</strong>,没有<strong>参数</strong>,只有方法体,而且不用通过对象或类显式调用,而是加载类时,或创建对象时隐式调用</p>
<ul>
<li>基本语法: [修饰符]{代码};</li>
<li>注意:
<ul>
<li>修饰符可选,要写的话,也只能写static</li>
<li>代码块分为两类,使用static修饰的叫静态代码块,没有static修饰的,叫普通代码块</li>
<li>;可以写上,也可以忽略</li>
</ul>
</li>
<li>对于代码块理解:
<ul>
<li>相当于另外一种形式的构造器(对构造器的补充机制),可以做初始化的操作</li>
<li>如果多个构造器都有重复的语句,可以抽取到初始化块中,提高代码块的重用性</li>
</ul>
</li>
<li>代码块的调用优先于构造器</li>
<li><strong>关于代码块的细节</strong>
<ul>
<li>static代码块随着类的加载而被执行，并且只会执行一次。类加载的三种情况：
<ul>
<li>创建对象实例(new)</li>
<li>创建子类对象实例,父类也会被加载</li>
<li>使用类的静态成员(静态方法和变量)</li>
<li>使用子类的静态成员(静态方法和变量),父类也会被加载</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Cat.getA());<span class="comment">//调用子类的静态方法时，父类的代码块也会被执行</span></span><br><span class="line">         System.out.println(Cat.getA());<span class="comment">//再次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父类的代码块被执行</span></span><br><span class="line">    <span class="comment">// 子类的代码块被执行</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>普通代码块每创建一次(new),都会被调用(可以理解为构造器的拓展)</li>
<li>创建一个对象时，在一个类的调用顺序：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(静态代码块和静态属性初始化)--&gt;b(普通代码块和普通属性初始化)==&gt;c(调用构造器)</span><br></pre></td></tr></table></figure>
<p>当属于同级时,看代码顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被调用&quot;</span>); <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块被调用&quot;</span>); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> setB(); <span class="comment">//4</span></span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通属性&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> setA(); <span class="comment">//1</span></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被调用&quot;</span>); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态属性&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序:</span></span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="comment">// 静态代码块被调用</span></span><br><span class="line"><span class="comment">// 普通代码块被调用</span></span><br><span class="line"><span class="comment">// 普通属性</span></span><br><span class="line"><span class="comment">// 构造器被调用</span></span><br></pre></td></tr></table></figure>
<p>当有子类对象时,最终顺序如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(父类的静态代码块和静态属性)==&gt;b(子类的静态代码块和静态属性)==&gt;c(父类的普通代码块和普通属性)==&gt;d(父类的构造器)==&gt;e(子类的普通代码块和普通属性)==&gt;f(子类的构造器)</span><br></pre></td></tr></table></figure>
<ul>
<li>静态代码块只能调用静态成员(方法和属性),普通代码块都可以.</li>
</ul>
<p>==关于类加载的总结==<br>
当我们new一个实例对象后,本质上顺序为:(以下为个人理解,正确性未知)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a(从父类到该子类先加载所有的静态)==&gt;b(执行构造器)</span><br></pre></td></tr></table></figure>
<p>而构造器中隐藏了代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">//1</span></span><br><span class="line">执行该类所有普通代码块和属性方法 <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h5 id="4-单例设计模式">4. 单例设计模式</h5>
<p>采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法</p>
<p>步骤:</p>
<ol>
<li>构造器私有化</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<h6 id="饿汉式">饿汉式</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;<span class="comment">//私有构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">myGirl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;xxx&quot;</span>,<span class="number">18</span>); <span class="comment">//内部自行创建实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123; <span class="comment">//提供返回方法</span></span><br><span class="line">        <span class="keyword">return</span> myGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="懒汉式">懒汉式</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend myGirl ;<span class="comment">//只创建不new</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加载</span></span><br><span class="line">        <span class="keyword">if</span>(myGirl == <span class="literal">null</span>)&#123;</span><br><span class="line">            myGirl = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;xxx&quot;</span>,<span class="number">18</span>); <span class="comment">//用if来判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myGirl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对上述两种方法类加载时,静态方法和变量都会被加载,但一种方法类似于给实例对象赋值,调用了构造器,而第二种虽然也加载了构造器,但是没调用</p>
<h5 id="5-final关键字">5. final关键字</h5>
<p>可以修饰 类、属性、方法、局部变量<br>
一般用XX_XX修饰，也就是常量<br>
应用场景</p>
<ul>
<li>不希望类被继承时</li>
<li>不希望父类的某个方法被子类覆盖时</li>
<li>不希望类的某个属性值被修改时</li>
<li>不希望某个局部变量被修改时</li>
</ul>
<p>注意细节</p>
<p>final修饰时必须赋初值</p>
<ul>
<li>以下三种合理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FINAL_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//定义时初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FINAL_</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        B = b;<span class="comment">//构造器初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        C = <span class="number">3</span>; <span class="comment">//代码块初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果修饰静态，则初始化位置只能是定义时或静态代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FINAL_</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> B;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FINAL_</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        B = b;<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        C = <span class="number">3</span>;<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为定义的静态变量时，必须要求加载时完成初始化，后续不能再进行修改</p>
<ul>
<li>final类不能被继承，但是可以实例化对象(废话…)</li>
<li>如果不是final类,但是有final方法,则该方法可以被继承(也是废话…)</li>
<li>类已经final了,里面方法没必要再添加final(已经不能继承了…)</li>
<li>final不能修饰构造器(也是废话…)</li>
<li>final和static往往搭配使用,效率更高,底层编译器做了优化处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">static_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(XXX.A);  <span class="comment">//只输出1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>包装类(Integer,Double,Float,Boolean,String)等都是final</li>
</ul>
<h5 id="6-抽象类">6. 抽象类</h5>
<p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类细节</p>
<ul>
<li>抽象类不能被实例化</li>
<li>抽象类可以没有抽象方法</li>
<li>abstract只能修饰类和方法</li>
<li>一个类继承抽象类时,则必须实现其所有方法,除非自己也声明为abstract类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YYY</span> <span class="keyword">extends</span> <span class="title class_">XXX</span>&#123; <span class="comment">//实现父类XXX f()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ZZZ</span> <span class="keyword">extends</span> <span class="title class_">XXX</span>&#123;<span class="comment">//也声明为抽象方法</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象方法不能使用private,final和static来修饰,因为这些关键字都是和重写相违背的</li>
</ul>
<h5 id="7-抽象类的最佳实践-模板设计模式">7. 抽象类的最佳实践(模板设计模式)</h5>
<p>本质原理是动态绑定机制,仔细品味以下妙处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">cal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job();<span class="comment">//抽象方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            res +=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() ;</span><br><span class="line">        System.out.println(a.cal());</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">B</span>() ;</span><br><span class="line">        System.out.println(b.cal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-接口">8. 接口</h5>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interface 接口名 &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法(抽象方法,默认实现方法,静态方法)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">//自己属性</span></span><br><span class="line">    <span class="comment">//自己方法</span></span><br><span class="line">    <span class="comment">//必须实现的接口的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jdk7.0前,接口里的所有方法都没有方法体.在jdk8后接口中可以有静态方法,默认方法,也就是接口中可以有方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//允许</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>); <span class="comment">//添加default</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">okk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;okk&quot;</span>); <span class="comment">//或者添加static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口使用细节</p>
<ul>
<li>抽象类实现接口，可以不用实现接口的方法</li>
<li>一个类可以同时实现多个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">IA</span>,IB&#123;&#125; <span class="comment">//使用implements</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接口中的属性是public,static,final修饰符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>&lt;==&gt;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接口不能继承其他的类,但是可以继承多个别的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IC</span> <span class="keyword">extends</span> <span class="title class_">IB</span>,IC <span class="comment">//extends</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接口的修饰符只能是<strong>默认</strong>和<strong>public</strong></li>
<li>接口的多态传递现象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IA</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">        test.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IB</span> <span class="keyword">extends</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">IB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现了IA的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IB继承IA,X实现了IB，</span></span><br></pre></td></tr></table></figure>
<h5 id="9-内部类">9. 内部类</h5>
<h6 id="局部内部类">局部内部类</h6>
<ul>
<li>定义在外部类的局部位置,通常在方法</li>
<li>可以访问外部类的所有成员，包括私有</li>
<li>不能添加访问修饰符，可以用final修饰(因为其实是局部变量)</li>
<li>作用域：仅仅在定义它的方法或代码块中,所以外部其他类不能访问该类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nei</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//可以访问外部类的所有成员，包括私有的</span></span><br><span class="line">                System.out.println(n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">//代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Inner01</span> &#123;</span><br><span class="line">                <span class="type">int</span> n2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果与外部类重名，遵循就近原则，调用外部成员可用 外部类.this.成员 的形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Nei</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//可以访问外部类的所有成员，包括私有的</span></span><br><span class="line">                System.out.println(Nei.<span class="built_in">this</span>.n1);<span class="comment">//调用外部类的n1的格式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//输出100</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="匿名内部类-重要">匿名内部类(重要!!!)</h6>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是A的匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是B的匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">//</span></span><br><span class="line">        a.test();</span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>性质与内部类性质一致</li>
<li>应用,例如:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Anom</span> <span class="variable">anom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Anom</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        anom.f(b); <span class="comment">//传统方法</span></span><br><span class="line">        anom.f(<span class="keyword">new</span> <span class="title class_">B</span>() &#123; <span class="comment">//采用匿名内部类的写法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我实现了接口B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        b.cry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我实现了接口B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="成员内部类">成员内部类</h6>
<ul>
<li>其性质也与局部内部类相似</li>
<li>可以添加任意访问修饰符,因为其本质为成员(private,public,默认,protected)</li>
<li>外部其他类可以访问到成员内部类.访问方式:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//第一种</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> a.getB(); <span class="comment">//第二种</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().<span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//或者直接new,如果不需要a实例对象的话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(A.<span class="built_in">this</span>.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="静态内部类">静态内部类</h6>
<ul>
<li>可以访问外部类的所有静态成员</li>
<li>可以加访问修饰符(private,默认,protected,public)</li>
<li>作用域同其他成员</li>
<li>外部类访问静态内部类,先创建对象再访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//先创建对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外部其他类访问内部静态类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Anom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>.B();<span class="comment">//第一种方法,其实就是不用再创建A的实例对象</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>().getB(); <span class="comment">//第二种方法,需要用到A的普通方法,所以这里需要创建A的实例对象</span></span><br><span class="line">        A.<span class="type">B</span> <span class="variable">b3</span> <span class="operator">=</span> A.getBB(); <span class="comment">//第三种方法,也不用创建A</span></span><br><span class="line">        b3.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(A.n1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B <span class="title function_">getBB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可通过类名.成员名去访问外部成员,如上例的f()函数</li>
</ul>
<h3 id="枚举和注解">枚举和注解</h3>
<h5 id="1-枚举类">1. 枚举类</h5>
<ul>
<li>枚举是一组常量的集合,是一种特殊的类,里面只包含有限的特定的对象</li>
<li>实现方式
<ol>
<li>自定义</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 将构造器私有化,防止直接被new</span></span><br><span class="line"><span class="comment">//2. 去掉setXXX方法,防止属性被修改</span></span><br><span class="line"><span class="comment">//3. 再Season内部,直接创建固定的对象</span></span><br><span class="line"><span class="comment">//4. 优化,再加入final修饰符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String name ;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>enum关键字</li>
</ol>
<ul>
<li>使用关键字enum代替class</li>
<li>将定义常量对象写在最前面</li>
<li>格式:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>),ME;<span class="comment">//多个常量对象之间用逗号隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们使用enum关键字开发一个枚举类时,默认会继承Enum类,而且是一个<strong>final</strong>类</li>
<li>但enum实现的枚举类仍然是一个类，所以还是可以实现接口的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当使用无参构造器创建枚举对象时,参数列表和<strong>小括号</strong>都可以省略</p>
</li>
<li>
<p>常用enum方法如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN.name()); <span class="comment">//1. AUTUMN(返回该对象的名称)</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Season.SUMMER.ordinal()); <span class="comment">//2. 1 (从0开始)</span></span><br><span class="line"></span><br><span class="line">        Season[] values = Season.values(); <span class="comment">//3. 得到所有枚举对象的一个数组</span></span><br><span class="line">        <span class="keyword">for</span> (Season season : values) &#123;</span><br><span class="line">            System.out.println(season.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Season.valueOf(<span class="string">&quot;AUTUMN&quot;</span>).name()); <span class="comment">//4. valueOf，将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</span></span><br><span class="line">        System.out.println(Season.SPRING.compareTo(Season.SUMMER)); <span class="comment">//5. 将两对象的ordinal进行比较返回第一个的编号减去第二个的编号</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>), AUTUMN(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>),ME;<span class="comment">//多个常量对象之间用逗号隔开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-注解">2. 注解</h5>
<ul>
<li>Override</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;<span class="comment">//看到类似的代码表示注解</span></span><br><span class="line"><span class="comment">//@target是Override的注解,称为元注解</span></span><br><span class="line"><span class="comment">//@Override只能修饰方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Deprecated</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span><span class="comment">//不推荐使用,但是仍然可以使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="comment">//可以修饰方法\类\字段\包\参数等等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the version in which the annotated element became deprecated.</span></span><br><span class="line"><span class="comment">     * The version string is in the same format and namespace as the value of</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> <span class="doctag">@since</span>&#125; javadoc tag. The default value is the empty</span></span><br><span class="line"><span class="comment">     * string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the version string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">since</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates whether the annotated element is subject to removal in a</span></span><br><span class="line"><span class="comment">     * future version. The default value is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether the element is subject to removal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">forRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SuppressWarings</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unused&quot;,&quot;&quot;&#125;)</span><span class="comment">//抑制的警告类型</span></span><br><span class="line"><span class="comment">//放在具体的位置来抑制警告信息</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;<span class="doctag">@code</span> &quot;unchecked&quot;&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于元注解</li>
</ul>
<ol>
<li>Retention</li>
<li>Target</li>
<li>Documented</li>
<li>Inherited</li>
</ol>
<h3 id="异常">异常</h3>
<p><img src="Throwable.png" alt=""><br>
五大运行时异常</p>
<ul>
<li>NullPointerException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(name.length());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ArithmeticException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ArraylndexOutOfBoundsException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        a[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ClassCastException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">       <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> (B) b; <span class="comment">//向下转型</span></span><br><span class="line">       <span class="type">C</span> <span class="variable">b2</span> <span class="operator">=</span>(C) b; <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NumberFormatException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;asff&quot;</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>try catch异常处理
<ol>
<li>可以有多个catch语句，捕获不同的异常(进行不同的业务处理),要求子类异常在前，父类一场在后，如果发生异常，只会匹配一个catch</li>
<li>可以进行try-finally配合使用，不管发不发生异常，程序都会崩溃。不管程序异不异常，都必须执行finally的业务逻辑。<br>
下面注意一个很怪的练习</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[<span class="number">3</span>].equals(<span class="string">&quot;zxcs&quot;</span>)) &#123; <span class="comment">//首先是数组索引越界异常,才是空指针异常</span></span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还要被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出: 我还要被执行 2</span></span><br><span class="line"><span class="comment">//无论如何，程序一定会把所有都执行完毕才会返回，交换顺序照样得到一样的结果</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[<span class="number">3</span>].equals(<span class="string">&quot;zxcs&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回 3,最后才会返回</span></span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>对于编译异常，程序必须处理</li>
<li>对于运行时异常，程序如果没有处理，默认是throws的方式处理</li>
<li>子类重写父类的方法时，对抛出异常的规定：所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//false ,不允许出现类似的情况</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果有trycatch，就不必throws</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        f2(); <span class="comment">//false</span></span><br><span class="line">        f3(); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义异常</p>
<ul>
<li>一般继承RuntimeException，比较方便</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;异常&quot;</span>); <span class="comment">//使用的是throw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="throw和throws区别">throw和throws区别</h6>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody>
</table>
<p>下面该练习值得好好推敲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            A.f1();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        A.f2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我进入f1方法&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主动抛出的异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1方法进入finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我进入了方法B&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f2方法进入finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用类">常用类</h3>
<h5 id="包装类-wrapper">包装类(Wrapper)</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph BT</span><br><span class="line">b(Byte)==&gt;n(Number)</span><br><span class="line">i(integer)==&gt;n</span><br><span class="line">l(Long)==&gt;n</span><br><span class="line">f(Float)==&gt;n</span><br><span class="line">d(Double)==&gt;n</span><br><span class="line">s(Short)==&gt;n</span><br><span class="line">b(Byte)==&gt;c(Comparable)</span><br><span class="line">i(integer)==&gt;c</span><br><span class="line">l(Long)==&gt;c</span><br><span class="line">f(Float)==&gt;c</span><br><span class="line">d(Double)==&gt;c</span><br><span class="line">s(Short)==&gt;c</span><br><span class="line">n==&gt;o(Object)</span><br><span class="line">n==&gt;Serializable(Serializable)</span><br><span class="line">Boolen(Boolen)==&gt;o</span><br><span class="line">Boolen==&gt;Serializable</span><br><span class="line">Boolen==&gt;c</span><br><span class="line">Character(Character)==&gt;o</span><br><span class="line">Character==&gt;Serializable</span><br><span class="line">Character==&gt;c</span><br></pre></td></tr></table></figure>
<p>包装类的基本数据类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1); <span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1); <span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> integer.intValue(); <span class="comment">//手动拆箱,注意拆箱用的是实例对象的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱和拆箱,jdk5之后</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> integer;</span><br></pre></td></tr></table></figure>
<p>一个细节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="number">1</span> : <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">//obj = 1.0;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字转字符串类型的方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> integer.toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> Integer.toString(<span class="number">123</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> String.valueOf(integer);</span><br><span class="line"><span class="type">String</span> <span class="variable">string4</span> <span class="operator">=</span> integer + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符转数字的方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.valueOf(string1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(string1);    </span><br><span class="line"><span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(string1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(integer1 == integer2);<span class="comment">//true</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(integer1 == integer2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.println(integer1 == integer3);<span class="comment">//只要出现基本数据类型,比较的是值的大小</span></span><br></pre></td></tr></table></figure>
<h5 id="string-类">String 类</h5>
<p><img src="String.png" alt=""></p>
<p>保存字符串，而字符串的字符通常采用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p>
<ul>
<li>String是final类,不能被其他类继承.</li>
<li>String的属性 private final char value[];用于存放字符串内容</li>
<li>一定要注意:value是一个final类型,不可以修改(<strong>指的是地址不能被修改</strong>)</li>
<li>两种创建String方式的区别</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">String b= <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">System.out.println(a == b) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//常量池创建,如果已有,则直接指向该常量池地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span>;</span><br><span class="line">System.out.println(str == <span class="string">&quot;ya&quot;</span>);<span class="comment">//true,&quot;ya&quot;直接是常量池的地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>String.intern()方法,返回常量池相同的字符串的地址</li>
<li>String特性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span> + <span class="string">&quot;ng&quot;</span>;<span class="comment">//编译器一共创建了一个对象,因为其会做底层优化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;ya&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ng&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> str1 + str2;<span class="comment">//创建了四个地址,需要深入了解底层实现机制</span></span><br><span class="line">System.out.println(end == str); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结:</span></span><br><span class="line"><span class="comment">//1. StringBuilder sb = new StringBuilder;</span></span><br><span class="line"><span class="comment">//2. sb.append(str1);</span></span><br><span class="line"><span class="comment">//3. sb.append(str2);</span></span><br><span class="line"><span class="comment">//4. String end = sb.toString();</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量相加,看的是池;变量相加,是在堆中</li>
</ul>
<p>一道测试题，主要考察之前的方法传参机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;yang&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str,<span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str );</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//yang</span></span><br><span class="line">    <span class="comment">//hbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String类的常见方法(没有改变原对象,需要被接受返回值)</p>
<ul>
<li>equals</li>
<li>equalsIgnoreCase(忽略大小写)</li>
<li>length</li>
<li>indexOf(字符在字符串中第一次出现的位置,且从0开始)(还可以是字符串)</li>
<li>lastIndexOf(字符在字符串中最后一次出现的位置,也从0开始)</li>
<li>substring(index1,index2)(从index1开始到index2)</li>
<li>toUpperCase(转大写)</li>
<li>toLowerCase(转小写)</li>
<li>concat(str.concat(&quot;&quot;))(拼接)</li>
<li>replace(substr1,target)(将substr1替换成target)</li>
<li>split()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦&quot;</span>;</span><br><span class="line">       String [] s = str.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            System.out.println(s[i]);</span><br><span class="line">        &#125;<span class="comment">//结果返回一个数组</span></span><br><span class="line">        <span class="comment">//如果有特殊字符，需要转移字符，如要替换/应该是//</span></span><br></pre></td></tr></table></figure>
<ul>
<li>toCharArray(转换为字符数组)</li>
<li>compareTo(比较两个字符串的大小)(比较规则:若长度不等,返回长度的差值;否则从0开始比较,直到遇到第一组不相等的字符,返回其码值大小差)</li>
<li>format(&quot;&quot;,变量名)(c语言的printf格式)</li>
</ul>
<p>StringBuffer类<br>
<img src="StringBuffer.png" alt=""></p>
<ul>
<li>在父类中，AbstractStringBuilder有属性 char[] value，不是final(因此存放在堆中)</li>
<li>StringBuffer构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">//capacity = 16</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">100</span>); <span class="comment">//capacity = 100</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">//capacity = 16 + 5</span></span><br></pre></td></tr></table></figure>
<p>StringBuffer 的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">//String转成StringBuffer</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(string);<span class="comment">//返回的才是StringBuffer对象</span></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer1.append(string);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//StringBuffer转成String</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer1.toString();</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>StringBuffer常见方法(是直接对实例对象进行的修改)
<ol>
<li>增:append()</li>
<li>删:delete(index1,index2)(删除index1到index2-1位置的字符)</li>
<li>改:replace(index1,index2,target)(替换index1到index2-1的字符为target)(与String类有差异,注意辨别)</li>
<li>查:indexOf()</li>
<li>insert(index.target)(在索引为index位置插入target,原来索引自动后移)</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">stringBuffer.insert(<span class="number">1</span>,<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer);</span><br><span class="line"><span class="comment">//ainsertbc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>length()</li>
</ul>
<p>一些练习题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer.append(string);</span><br><span class="line">System.out.println(stringBuffer);</span><br><span class="line"><span class="comment">////输出null,需要看底层原码,底层调用AbstractStringBuilder的appendNull,赋予了长度为4的字符串null</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(string);</span><br><span class="line">System.out.println(stringBuffer1);</span><br><span class="line"><span class="comment">//抛出空指针异常,也是需要看底层原码</span></span><br></pre></td></tr></table></figure>
<h5 id="stringbulider类">StringBulider类</h5>
<p>介绍:一个可变的字符序列,此类提供一个与StringBuffer兼容的API,但不保证同步(StringBuilder 不是线程安全).该类被设计用作StringBuffer的一个简易替换,用在字符串缓冲区被单个线程使用的时候.如果可能,建议优先采用该类.</p>
<ul>
<li>主要使用append和insert方法,可重载这些方法,已接受任意类型的数据<br>
<img src="StringBuilder.png" alt=""></li>
</ul>
<h3 id="泛型">泛型</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">听灵</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/20/Java/">http://example.com/2024/03/20/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">半夏琉璃空</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="post-share"><div class="social-share" data-image="/images/ava.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/03/20/C/" title="C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++</div></div></a><a class="next-post pull-right" href="/2024/03/20/Liinux/" title="Linux基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux基础</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2024/03/20/C/" title="C++"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">C++</div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/images/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">听灵</div><div class="author-info-description">Journey of a thousand miles begins with single step</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number">1.</span> <span class="toc-text">一些技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 断点调试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-jdk%E4%B8%8Ejre"><span class="toc-number">0.1.</span> <span class="toc-text">1. JDK与JRE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">0.2.</span> <span class="toc-text">2. 文档注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-java%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%BB%86%E8%8A%82"><span class="toc-number">0.3.</span> <span class="toc-text">3. Java中的变量细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%BC%BA%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">0.4.</span> <span class="toc-text">4. 强制数据类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%86%E8%8A%82"><span class="toc-number">0.5.</span> <span class="toc-text">5. java中的运算符细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">0.6.</span> <span class="toc-text">6. 进制表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="toc-number">0.7.</span> <span class="toc-text">6. 关于数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80-java%E5%88%9D%E7%BA%A7"><span class="toc-number">1.</span> <span class="toc-text">一. Java初级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.1.</span> <span class="toc-text">关于方法重载注意事项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">关于作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ethis"><span class="toc-number">1.0.5.</span> <span class="toc-text">关于this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C-java%E4%B8%AD%E7%BA%A7"><span class="toc-number">2.</span> <span class="toc-text">二. java中级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%8C%85"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 访问修饰符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%B0%81%E8%A3%85-encapsulation"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 封装(encapsulation)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E7%BB%A7%E6%89%BF-extends"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. 继承(extends)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%A4%9A%E6%80%81-polymorphic"><span class="toc-number">2.0.5.</span> <span class="toc-text">5. 多态(polymorphic)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.0.6.</span> <span class="toc-text">6. &#x3D;&#x3D;运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-equals%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.7.</span> <span class="toc-text">7. equals方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.8.</span> <span class="toc-text">8. hashCode方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9-tostring%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.9.</span> <span class="toc-text">9. toString方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-finalize%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">10. finalize方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89-java%E9%AB%98%E7%BA%A7"><span class="toc-number">3.</span> <span class="toc-text">三. java高级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1. 类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">类变量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">类方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-main%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">2. main方法的语法说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">3.代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">4. 单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">懒汉式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.5.</span> <span class="toc-text">5. final关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">6. 抽象类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">7. 抽象类的最佳实践(模板设计模式)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.8.</span> <span class="toc-text">8. 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">9. 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.9.1.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-%E9%87%8D%E8%A6%81"><span class="toc-number">3.9.2.</span> <span class="toc-text">匿名内部类(重要!!!)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.9.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.9.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number"></span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">0.1.</span> <span class="toc-text">1. 枚举类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E8%A7%A3"><span class="toc-number">0.2.</span> <span class="toc-text">2. 注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number"></span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#throw%E5%92%8Cthrows%E5%8C%BA%E5%88%AB"><span class="toc-number">0.0.1.</span> <span class="toc-text">throw和throws区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-wrapper"><span class="toc-number">0.1.</span> <span class="toc-text">包装类(Wrapper)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-%E7%B1%BB"><span class="toc-number">0.2.</span> <span class="toc-text">String 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stringbulider%E7%B1%BB"><span class="toc-number">0.3.</span> <span class="toc-text">StringBulider类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">泛型</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/06/%E7%A7%91%E7%A0%94%E5%91%A8%E6%8A%A53/" title="科研周报3">科研周报3</a><time datetime="2024-10-06T08:25:49.000Z" title="发表于 2024-10-06 16:25:49">2024-10-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/27/%E7%A7%91%E7%A0%94%E5%91%A8%E6%8A%A52/" title="科研周报week_2">科研周报week_2</a><time datetime="2024-09-27T14:41:40.000Z" title="发表于 2024-09-27 22:41:40">2024-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/25/CIL/" title="分析类增量学习">分析类增量学习</a><time datetime="2024-09-25T08:07:03.000Z" title="发表于 2024-09-25 16:07:03">2024-09-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/24/%E8%BE%B9%E7%BC%98%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0/" title="边缘持续学习">边缘持续学习</a><time datetime="2024-09-24T06:55:17.000Z" title="发表于 2024-09-24 14:55:17">2024-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/datawhale/" title="datawhale夏令营(2)">datawhale夏令营(2)</a><time datetime="2024-08-12T09:09:36.000Z" title="发表于 2024-08-12 17:09:36">2024-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By 听灵</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ICRQxrzClZlxLlYVZGMjVxyq-gzGzoHsz',
      appKey: '3xXv1c0qQMQnKNoT9QA0HtiN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>